<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>交个朋友之猿天地 | 微服务 | 容器化 | 自动化</title>
  
  <subtitle>交个朋友之猿天地</subtitle>
  <link href="http://xiao8.github.io/atom.xml" rel="self"/>
  
  <link href="http://xiao8.github.io/"/>
  <updated>2022-07-28T07:07:24.916Z</updated>
  <id>http://xiao8.github.io/</id>
  
  <author>
    <name>交个朋友之猿天地</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>云原生时代微服务架构设计实践</title>
    <link href="http://xiao8.github.io/2022/06/11/cloudnative-microservice/"/>
    <id>http://xiao8.github.io/2022/06/11/cloudnative-microservice/</id>
    <published>2022-06-11T01:50:01.000Z</published>
    <updated>2022-07-28T07:07:24.916Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>微服务架构已经火了很多年了，如：Dubbo、Spring Cloud，再到后来的 Spring Cloud Alibaba，但都是仅限于 Java 语言的瓶颈，如何让各种语言之间的微服务更加有效、快速的通讯，这是当前很多企业需要面临的问题，因为一个企业中，不只是基于单纯的某一种语言开发，这就涉及到多语言服务之间的访问。以 Kubernetes（k8s） 为核心的容器技术掀起的云原生浪潮仍在席卷全球，在轰轰烈烈的数字化转型技术变革中，先行者们开始思考新的技术体系究竟能给行业与社会带来什么，以及如何把 DevOps 等先进的开发管理模型带入各行各业，让更多的企业享受到云原生以及 AI、IoT 等前沿技术革新带来的红利。本专栏的创作重点，则是在于讲述在巨多语言的情况下，该如何设计微服务架构，以及云原生时代的微服务的高可用、自动化等等。</p><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><h4 id="微服务发展史"><a href="#微服务发展史" class="headerlink" title="微服务发展史"></a>微服务发展史</h4><p>在微服务到来之前，一切都是单个服务，当然单体应用程序的存在，暴露的缺点也是不少的，主要有：</p><ul><li>复杂性高</li><li>团队协作开发成本高</li><li>扩展性差</li><li>部署效率低下</li><li>系统很差的高可用性</li></ul><p>复杂性，体现在：随着业务的不断迭代，项目的代码量急剧的增多，项目模块也会随着而增加，整个项目就会变成的非常复杂。</p><p>开发成本高，体现在：团队开发几十个人在修改代码，然后一起合并到同一地址分支，打包部署，测试阶段只要有一小块功能有问题，就得重新编译打包部署，重新测试，所有相关的开发人员都得参与其中，效率低下，开发成本极高。</p><p>扩展性差，体现在：在新增功能业务的时候，代码层面会考虑在不影响现有的业务基础上编写代码，提高了代码的复杂性。</p><p>部署效率低，体现在：当单体应用的代码越来越多，依赖的资源越来越多时，应用编译打包、部署测试一次，需要花费的时间越来越多，导致部署效率低下。</p><p>高可用差，体现在：由于所有的业务功能最后都部署到同一个文件，一旦某一功能涉及的代码或者资源有问题，那就会影响到整个文件包部署的功能。举个特别鲜明的示例：上世纪八、九十年代，很多的黄页以及延伸到后来的网站中，很多的展示页面与获取数据的后端都是在一个服务模块中。这就造成一个很不好的影响：如果只是修改极小部分的页面展示或图片展示，则需要把整个服务模块进行打包部署，这样会导致时间的严重浪费以及成本的增加。更加糟糕的是，给用户带来非常不好的体验，用户无法理解的是：只是换个网站的某块微小的展示区，导致了整个网站在那一时刻无法正常的访问。当然，也许，对于那个时候互联网的不发达，人们对于这样的体验，已经算是一种幸福的享受了。</p><p>由于单体应用具有以上的种种缺点，导致了一个新名词、新概念的诞生——<strong>微服务</strong>。</p><p>其实，从早年间的单体应用，到 2014 年起，得益于以 Docker 为代表的容器化技术的成熟以及 DevOps 文化的兴起，服务化的思想进一步演化，演变为今天我们所熟知的微服务。那么，微服务到底是啥？</p><p>微服务，英文名：microservice，百度百科上将其定义为：SOA 架构的一种变体。微服务（或微服务架构）是一种将应用程序构造为一组低耦合的服务。</p><p>微服务有着一些鲜明的特点：</p><ul><li>功能单一</li><li>服务粒度小</li><li>服务间独立性强</li><li>服务间依赖性弱</li><li>服务独立维护</li><li>服务独立部署</li></ul><p><strong>微服务</strong>将原来耦合在一起的复杂业务拆分为单个服务，规避了原本复杂度无止境的积累，每一个微服务专注于单一功能，并通过定义良好的接口清晰表述服务边界。</p><p>由于微服务具备独立的运行进程，所以每个微服务可以独立部署。当业务迭代时只需要发布相关服务的迭代即可，降低了测试的工作量同时也降低了服务发布的风险。</p><p>在微服务架构下，当某一组件发生故障时，故障会被隔离在单个服务中。如通过限流、熔断等方式降低错误导致的危害，保障核心业务的正常运行。</p><p>微服务发展到现在，带有以下标志：<strong>高内聚、低耦合</strong>，<strong>以业务为中心</strong>，<strong>自治和高可用</strong>。</p><h4 id="微服务划分的粒度"><a href="#微服务划分的粒度" class="headerlink" title="微服务划分的粒度"></a>微服务划分的粒度</h4><p>服务的划分，可以从水平的功能划分，也可从垂直的业务划分，粒度的大小，可以根据当前的产品需求来定位，最关键的是要做到：<strong>高内聚、低耦合</strong>。</p><p>如电商系统为例，如下图：</p><p><img src="https://files.mdnice.com/user/7503/7284adaa-a21b-46e5-a37a-4a95ab256d54.jpg" alt="电商系统架构图"></p><p>电商中涉及到业务很可能是最多的，商品、库存、订单、促销、支付、会员、购物车、发票、店铺等等，这个是根据业务的不同来进行模块的划分。微服务划分的粒度一定是要有明确性的，不能因为含糊而新增一个服务模块，这样会导致功能接口的可复用性差。一个好的架构设计，肯定是可复用性很强的结构模式。我喜欢这样的一句话：**微服务的边界 (粒度) 是 “决策”, 而不是个 “标准答案”**。即应该将各微服务划分的方式，深度思考，周全的考量各方面的因素下，所作出的一个”最适合”的架构决策，而不是一个人芸亦芸的”标准答案“。</p><h3 id="容器化技术"><a href="#容器化技术" class="headerlink" title="容器化技术"></a>容器化技术</h3><h4 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h4><p>什么是容器呢？自然界的解释：容器是指用以容纳物料并以壳体为主的基本装置。但今天讲的容器也是一个容纳物质的载体。那计算机所指的容器（Container）到底是什么呢？容器是镜像（Image）的运行时实例。正如从虚拟机模板上启动 VM 一样，用户也同样可以从单个镜像上启动一个或多个容器。虚拟机和容器最大的区别是容器更快并且更轻量级，与虚拟机运行在完整的操作系统之上相比，容器会共享其所在主机的操作系统/内核。</p><p>为什么要用容器呢？假设你在使用一台电脑开发一个应用，而且开发环境具有特定的配置。其他开发人员身处的环境配置可能稍有不同。你正在开发的应用不止依赖于您当前的配置，还需要某些特定的库、依赖项和文件。与此同时，你的企业还拥有标准化的开发和生产环境，有着自己的配置和一系列支持文件。你希望尽可能多在本地模拟这些环境，而不产生重新创建服务器环境的开销。这时候，就会需要容器来模拟这些环境。</p><p>我们常见的容器启动方式是 Docker，Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何 Linux 机器上，也可以实现虚拟化。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22eb5bb9126a4a3ba926f08d4515a9b5~tplv-k3u1fbpfcp-zoom-1.image"></p><h4 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h4><p>Google 多年来一直使用容器作为交付应用程序的一种重要方式，且运行有一款名为 Borg 的编排工具。Google、RedHat 等公司为了对抗以 Docker 公司为核心的容器商业生态，他们一起成立了 CNCF(Cloud Native Computing Foundation)。当谷歌于 2014 年 3 月开始开发 Kubernetes 时，很明智的选择当时最流行的容器，没错，就是 Docker。Kubernetes 对 Docker 容器运行时的支持，迎来了大量的使用用户。Kubernetes 于 2014 年 6 月 6 日首次发布。这便有了容器编排工具 Kubernetes 的诞生。另外，CNCF 的目的是以开源的 K8S 为基础，使得 K8S 能够在容器编排方面能够覆盖更多的场景，提供更强的能力。K8S 必须面临 Swarm 和 Mesos 的挑战。Swarm 的强项是和 Docker 生态的天然无缝集成，Mesos 的强项是大规模集群的管理和调度。K8S 是 Google 基于公司已经使用了十多年的 Borg 项目进行了沉淀和升华才提出的一套框架。它的优点就是有一套完整的全新的设计理念，同时有 Google 的背书，而且在设计上有很强的扩展性，所以，最终 K8S 赢得了胜利，成为了容器生态的行业标准。</p><h3 id="K8s-为什么会成为微服务的基础架构"><a href="#K8s-为什么会成为微服务的基础架构" class="headerlink" title="K8s 为什么会成为微服务的基础架构"></a>K8s 为什么会成为微服务的基础架构</h3><h4 id="为什么-K8s-是下一代微服务架构基础"><a href="#为什么-K8s-是下一代微服务架构基础" class="headerlink" title="为什么 K8s 是下一代微服务架构基础"></a>为什么 K8s 是下一代微服务架构基础</h4><p>微服务出现后，同样面临着一个重要的话题：高可用。所谓<strong>高可用</strong>：英文缩写 HA（High Availability），是指当某个服务或服务所在节点出现故障时，其对外的功能可以转移到该服务其他的副本或该服务在其他节点的副本，从而在减少停工时间的前提下，满足业务的持续性，这两个或多个服务构成了服务高可用。同时，这种高可用需要考虑到服务的性能压力，即服务的负载均衡。</p><p>我们知道对于服务的高可用，或者说服务的负载来说，有很多方式来解决这些问题。比如：</p><ul><li>主从方式，其工作原理是：主机处于工作状态，备机处于监控、准备状态，当主机出现宕机的情况下，备机可以接管主机的一切工作，等到主机恢复正常后，将会手动或自动的方式将服务切换到主机上运行，数据的一致性通过共享存储来实现。</li><li>集群方式，其工作原理是：多台机器同时运行一个或几个服务，当其中的某个节点出现宕机时，这时该节点的服务将无法提供业务功能，可以选择根据一定的机制，将服务请求转移到该服务所在的其他节点上，这样可以让逻辑持续的执行下去，即消除软件单点故障。这其实就涉及到负载均衡策略。</li></ul><p>对于微服务的<strong>高可用</strong>，涉及到的其中一个就是其服务的负载均衡。在微服务中，负载均衡的前提是，同一个服务需要被发现多个，或者说多个副本，这样才能实现负载均衡以及服务的高可用。</p><p>同时，服务发现后，其实面临的是一个主要的问题就是应该访问哪一个？因为发现了某个服务的多个实例，最终只会访问其中某一个，这就涉及到服务的负载均衡了。</p><p>负载均衡在微服务中是一个很常见的话题，实现负载均衡的插件也越来越多。netflix 开源的 Zuul、Gateway 等等。</p><p>但这样的微服务，带来的好处就是高度自治，但同时也会带来一定的副作用：所用到的技术栈太过复杂，整个系统看起来很繁重。</p><p>K8s 是如何解决这些问题的呢？在 K8s 中提供了一套服务注册与发现的机制：Kubernetes 为服务和 Pod 创建 DNS 记录。您可以使用一致的 DNS 名称而不是 IP 地址联系服务。集群中定义的每个服务（包括 DNS 服务器本身）都分配了一个 DNS 名称。默认情况下，客户端 Pod 的 DNS 搜索列表包括 Pod 自己的命名空间和集群的默认域。DNS 查询可以使用 pod 的 /etc/resolv.conf. Kubelet 为每个 pod 设置这个文件。例如，对查询 data 可以扩展为 test.default.svc.cluster.local。该 search 选项的值用于扩展查询:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: test</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: MyApp</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 9376</span><br></pre></td></tr></tbody></table></figure><p>该规范创建了一个名为“test”的新服务对象，其目标是任何带有 <code>app=MyApp</code> 标签的 Pod 上的 TCP 端口 9376 。</p><p>同时，K8s 提供一种资源 Configmap，可以编写一个 spec 引用 ConfigMap 的 Pod ，并根据 ConfigMap 中的数据配置该 Pod 中的容器。Pod 和 ConfigMap 必须在同一个命名空间:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kind: ConfigMap</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: rest-service</span><br><span class="line">  namespace: system-server</span><br><span class="line">data:</span><br><span class="line">  application.yaml: |-</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the World</span><br><span class="line">    ---</span><br><span class="line">    spring:</span><br><span class="line">      profiles: dev</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Developers</span><br></pre></td></tr></tbody></table></figure><p>再者，对于服务的暴露，K8s 提供了一种资源：<strong>Ingress controller</strong>，Ingress 控制器类似 Nginx，可以帮助我们把服务代理到集群外，提供给前端或外界第三方使用。</p><p>这样，对于系统本身的复杂程度，可以摒弃使用 Spring cloud 自带的各种组件：</p><p><img src="https://files.mdnice.com/user/7503/d2f5e39a-ee16-4f20-8013-eee9ea1e7d13.png" alt="Spring Cloud 组件图"></p><h3 id="K8s-的基础以及实战"><a href="#K8s-的基础以及实战" class="headerlink" title="K8s 的基础以及实战"></a>K8s 的基础以及实战</h3><h4 id="K8s-基础"><a href="#K8s-基础" class="headerlink" title="K8s 基础"></a>K8s 基础</h4><p>在前面，我们讲述了 K8s 为什么可以替换 Springcloud 家族中的组件来统一管理服务、访问服务。接下来，我们讲讲 K8s 都有哪些基础常用的资源。这些资源在 K8s 中有其接口功能，但这里，我们统一用脚本命令的形式来调用接口，生成资源。</p><p>首先第一条就是编写配置文件，因为配置文件可以是 YAML 或者 JSON 格式的。为方便阅读与理解，在后面的讲解中，我会统一使用 YAML 文件来指代它们。 Kubernetes 跟 Docker 等很多项目最大的不同，就在于它不推荐你使用命令行的方式直接运行容器（虽然 Kubernetes 项目也支持这种方式，比如：kubectl run），而是希望你用 YAML 文件的方式，即：把容器的定义、参数、配置，统统记录在一个 YAML 文件中，然后用这样一句指令把它运行起来：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f xxx.yaml</span><br></pre></td></tr></tbody></table></figure><p>这样做最直接的一个好处是：你会有一个文件能记录下 K8s 到底 run 了哪些东西。比如下面这个例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: tomcat-deployment</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: tomcat</span><br><span class="line">  replicas: 2</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: tomcat</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: tomcat</span><br><span class="line">        image: tomcat:10.0.5</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></tbody></table></figure><p>像这样的一个 YAML 文件，对应到 kubernetes 中，就是一个 API Object（API 对象）。当你为这个对象的各个字段填好值并提交给 Kubernetes 之后，Kubernetes 就会负责创建出这些对象所定义的容器或者其他类型的 API 资源。可以看到，这个 YAML 文件中的 Kind 字段，指定了这个 API 对象的类型（Type），是一个 Deployment。Deployment 是一个定义多副本应用（即多个副本 Pod）的对象。此外，Deployment 还负责在 Pod 定义发生变化时，对每个副本进行滚动更新（Rolling+Update）。</p><p>在上面这个 Yaml 文件中，我给它定义的 Pod 副本个数 (spec.replicas)是：2。但，这些 Pod 副本长啥样子呢？为此，我们定义了一个 Pod 模版（spec.template），这个模版描述了我想要创建的 Pod 的细节。在上面的例子里，这个 Pod 里只有一个容器，这个容器的镜像（spec.containers.image）是 tomcat=10.0.5，这个容器监听端口（containerPort）是 80。</p><p>需要注意的是，像这种，使用一种 API 对象（Deployment）管理另一种 API 对象（Pod）的方法，在 Kubernetes 中，叫作“控制器”模式（controller pattern）。在我们的这个 demo 中，Deployment 扮演的正是 Pod 的控制器的角色。而 Pod 是 Kubernetes 世界里的应用；而一个应用，可以由多个容器（container）组成。为了让我们这个 tomcat 服务容器化运行起来，我们只需要执行：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tom@PK001:~/damon$ kubectl create -f tomcat-deployment.yaml</span><br><span class="line">deployment.apps/tomcat-deployment created</span><br></pre></td></tr></tbody></table></figure><p>执行完上面的命令后，你就可以看容器运行情况，此时，只需要执行：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tom@PK001:~/damon$ kubectl get pod -l app=tomcat</span><br><span class="line">NAME                                 READY   STATUS              RESTARTS   AGE</span><br><span class="line">tomcat-deployment-799f46f546-7nxrj   1/1     Running             0          77s</span><br><span class="line">tomcat-deployment-799f46f546-hp874   0/1     Running             0          77s</span><br></pre></td></tr></tbody></table></figure><p><code>kubectl get</code> 指令的作用，就是从 Kubernetes 里面获取（GET）指定的 API 对象。可以看到，在这里我还加上了一个 <code>-l</code> 参数，即获取所有匹配 app=nginx 标签的 Pod。需要注意的是，在命令行中，所有 key-value 格式的参数，都使用“=”而非“：”表示。 从这条指令返回的结果中，我们可以看到现在有两个 Pod 处于 Running 状态，也就意味着我们这个 Deployment 所管理的 Pod 都处于预期的状态。</p><p>此外， 你还可以使用 <code>kubectl describe</code> 命令，查看一个 API 对象的细节，比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">tom@PK001:~/damon$ kubectl describe pod tomcat-deployment-799f46f546-7nxrj</span><br><span class="line">Name:           tomcat-deployment-799f46f546-7nxrj</span><br><span class="line">Namespace:      default</span><br><span class="line">Priority:       0</span><br><span class="line">Node:           ca005/10.10.2.5</span><br><span class="line">Start Time:     Thu, 08 Apr 2021 10:41:08 +0800</span><br><span class="line">Labels:         app=tomcat</span><br><span class="line">                pod-template-hash=799f46f546</span><br><span class="line">Annotations:    cni.projectcalico.org/podIP: 20.162.35.234/32</span><br><span class="line">Status:         Running</span><br><span class="line">IP:             20.162.35.234</span><br><span class="line">Controlled By:  ReplicaSet/tomcat-deployment-799f46f546</span><br><span class="line">Containers:</span><br><span class="line">  tomcat:</span><br><span class="line">    Container ID:   docker://5a734248525617e950b7ce03ad7a19acd4ffbd71c67aacd9e3ec829d051b46d3</span><br><span class="line">    Image:          tomcat:10.0.5</span><br><span class="line">    Image ID:       docker-pullable://tomcat@sha256:2637c2c75e488fb3480492ff9b3d1948415151ea9c503a496c243ceb1800cbe4</span><br><span class="line">    Port:           80/TCP</span><br><span class="line">    Host Port:      0/TCP</span><br><span class="line">    State:          Running</span><br><span class="line">      Started:      Thu, 08 Apr 2021 10:41:58 +0800</span><br><span class="line">    Ready:          True</span><br><span class="line">    Restart Count:  0</span><br><span class="line">    Environment:    &lt;none&gt;</span><br><span class="line">    Mounts:</span><br><span class="line">      /var/run/secrets/kubernetes.io/serviceaccount from default-token-2ww52 (ro)</span><br><span class="line">Conditions:</span><br><span class="line">  Type              Status</span><br><span class="line">  Initialized       True</span><br><span class="line">  Ready             True</span><br><span class="line">  ContainersReady   True</span><br><span class="line">  PodScheduled      True</span><br><span class="line">Volumes:</span><br><span class="line">  default-token-2ww52:</span><br><span class="line">    Type:        Secret (a volume populated by a Secret)</span><br><span class="line">    SecretName:  default-token-2ww52</span><br><span class="line">    Optional:    false</span><br><span class="line">QoS Class:       BestEffort</span><br><span class="line">Node-Selectors:  &lt;none&gt;</span><br><span class="line">Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s</span><br><span class="line">                 node.kubernetes.io/unreachable:NoExecute for 300s</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age    From               Message</span><br><span class="line">  ----    ------     ----   ----               -------</span><br><span class="line">  Normal  Scheduled  4m17s  default-scheduler  Successfully assigned default/tomcat-deployment-799f46f546-7nxrj to ca005</span><br><span class="line">  Normal  Pulling    4m16s  kubelet, ca005     Pulling image "tomcat:10.0.5"</span><br><span class="line">  Normal  Pulled     3m27s  kubelet, ca005     Successfully pulled image "tomcat:10.0.5"</span><br><span class="line">  Normal  Created    3m27s  kubelet, ca005     Created container tomcat</span><br><span class="line">  Normal  Started    3m27s  kubelet, ca005     Started container tomcat</span><br></pre></td></tr></tbody></table></figure><p>在 kubectl describe 命令返回的结果中，可以的清楚地看到这个 Pod 的详细信息，比如它的 IP 地址等等。其中，有一个部分值得你特别关注，它就是 Events（事件）。</p><p>在 Kubernetes 执行的过程中，对 API 对象的所有重要操作，都会被记录在这个对象的 Events 里，并且显示在 kubectl describe 指令返回的结果中。这些 Events 中的信息很重要，可以排查容器是否运行、正常运行的原因。</p><p>如果你希望升级 tomcat 的版本，那可以直接修改 Yaml 文件：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: tomcat</span><br><span class="line">    image: tomcat:latest</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br></pre></td></tr></tbody></table></figure><p>修改完 Yaml 文件后，执行：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f tomcat-deployment.yaml</span><br></pre></td></tr></tbody></table></figure><p>这样的操作方法，是 Kubernetes“声明式 API”所推荐的使用方法。也就是说，作为用户，你不必关心当前的操作是创建，还是更新，你执行的命令始终是 kubectl apply，而 Kubernetes 则会根据 YAML 文件的内容变化，自动进行具体的处理。</p><p>同时，可以查看容器内的服务的日志情况：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">tom@PK001:~/damon$ kubectl logs -f tomcat-deployment-799f46f546-7nxrj</span><br><span class="line">NOTE: Picked up JDK_JAVA_OPTIONS:  --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/java.io=ALL-UNNAMED --add-opens=java.base/java.util=ALL-UNNAMED --add-opens=java.base/java.util.concurrent=ALL-UNNAMED --add-opens=java.rmi/sun.rmi.transport=ALL-UNNAMED</span><br><span class="line">08-Apr-2021 02:41:59.037 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server version name:   Apache Tomcat/10.0.5</span><br><span class="line">08-Apr-2021 02:41:59.040 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server built:          Mar 30 2021 08:19:50 UTC</span><br><span class="line">08-Apr-2021 02:41:59.040 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server version number: 10.0.5.0</span><br><span class="line">08-Apr-2021 02:41:59.040 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log OS Name:               Linux</span><br><span class="line">08-Apr-2021 02:41:59.040 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log OS Version:            4.4.0-116-generic</span><br><span class="line">08-Apr-2021 02:41:59.040 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Architecture:          amd64</span><br><span class="line">08-Apr-2021 02:41:59.040 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Java Home:             /usr/local/openjdk-11</span><br><span class="line">08-Apr-2021 02:41:59.040 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log JVM Version:           11.0.10+9</span><br><span class="line">08-Apr-2021 02:41:59.040 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log JVM Vendor:            Oracle Corporation</span><br><span class="line">08-Apr-2021 02:41:59.040 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log CATALINA_BASE:         /usr/local/tomcat</span><br><span class="line">08-Apr-2021 02:41:59.041 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log CATALINA_HOME:         /usr/local/tomcat</span><br><span class="line">08-Apr-2021 02:41:59.051 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.base/java.lang=ALL-UNNAMED</span><br><span class="line">08-Apr-2021 02:41:59.051 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.base/java.io=ALL-UNNAMED</span><br><span class="line">08-Apr-2021 02:41:59.051 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.base/java.util=ALL-UNNAMED</span><br><span class="line">08-Apr-2021 02:41:59.051 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.base/java.util.concurrent=ALL-UNNAMED</span><br><span class="line">08-Apr-2021 02:41:59.052 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.rmi/sun.rmi.transport=ALL-UNNAMED</span><br><span class="line">08-Apr-2021 02:41:59.052 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.util.logging.config.file=/usr/local/tomcat/conf/logging.properties</span><br><span class="line">08-Apr-2021 02:41:59.052 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager</span><br><span class="line">08-Apr-2021 02:41:59.052 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djdk.tls.ephemeralDHKeySize=2048</span><br><span class="line">08-Apr-2021 02:41:59.052 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.protocol.handler.pkgs=org.apache.catalina.webresources</span><br><span class="line">08-Apr-2021 02:41:59.052 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dorg.apache.catalina.security.SecurityListener.UMASK=0027</span><br><span class="line">08-Apr-2021 02:41:59.052 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dignore.endorsed.dirs=</span><br><span class="line">08-Apr-2021 02:41:59.052 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dcatalina.base=/usr/local/tomcat</span><br><span class="line">08-Apr-2021 02:41:59.052 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dcatalina.home=/usr/local/tomcat</span><br><span class="line">08-Apr-2021 02:41:59.052 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.io.tmpdir=/usr/local/tomcat/temp</span><br><span class="line">08-Apr-2021 02:41:59.056 INFO [main] org.apache.catalina.core.AprLifecycleListener.lifecycleEvent Loaded Apache Tomcat Native library [1.2.27] using APR version [1.6.5].</span><br><span class="line">08-Apr-2021 02:41:59.056 INFO [main] org.apache.catalina.core.AprLifecycleListener.lifecycleEvent APR capabilities: IPv6 [true], sendfile [true], accept filters [false], random [true], UDS [true].</span><br><span class="line">08-Apr-2021 02:41:59.059 INFO [main] org.apache.catalina.core.AprLifecycleListener.initializeSSL OpenSSL successfully initialized [OpenSSL 1.1.1d  10 Sep 2019]</span><br><span class="line">08-Apr-2021 02:41:59.312 INFO [main] org.apache.coyote.AbstractProtocol.init Initializing ProtocolHandler ["http-nio-8080"]</span><br><span class="line">08-Apr-2021 02:41:59.331 INFO [main] org.apache.catalina.startup.Catalina.load Server initialization in [441] milliseconds</span><br><span class="line">08-Apr-2021 02:41:59.369 INFO [main] org.apache.catalina.core.StandardService.startInternal Starting service [Catalina]</span><br><span class="line">08-Apr-2021 02:41:59.370 INFO [main] org.apache.catalina.core.StandardEngine.startInternal Starting Servlet engine: [Apache Tomcat/10.0.5]</span><br><span class="line">08-Apr-2021 02:41:59.377 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler ["http-nio-8080"]</span><br><span class="line">08-Apr-2021 02:41:59.392 INFO [main] org.apache.catalina.startup.Catalina.start Server startup in [61] milliseconds</span><br></pre></td></tr></tbody></table></figure><p>在这里，为什么会以 Deployment 资源来举例呢？因为在 K8s 资源中，Deployment 形式的资源提供了声明更新以及副本集，可以在 Deployment 中描述了“所需的状态”，并且 Deployment 以受控速率将实际状态更改为所需状态。您可以定义部署以创建新的副本集，或删除现有部署并通过新部署采用其所有资源。在 rc 滚动升级时，为了防止服务访问的中断，引入了 Deployment 资源。</p><p>接下来，我们看看 K8s 比较重要的资源 ConfigMap，其是为 Pod 的配置信息起作用，通过服务挂载的形式来提供各种配置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">kind: ConfigMap</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: rest-service</span><br><span class="line">  namespace: system-server</span><br><span class="line">data:</span><br><span class="line">  application.yaml: |-</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the World</span><br><span class="line">    ---</span><br><span class="line">    spring:</span><br><span class="line">      profiles: dev</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Developers</span><br><span class="line"></span><br><span class="line">    ---</span><br><span class="line">    spring:</span><br><span class="line">      profiles: test</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Test</span><br><span class="line">    ---</span><br><span class="line">    spring:</span><br><span class="line">      profiles: prod</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Prod</span><br></pre></td></tr></tbody></table></figure><p>当然，它支持各种形式的挂载，key-value 字符串、文件形式等。这在微服务中解耦合，非常重要，比如：在一次线上环境中，部署的服务可能需要对其某个或某几个参数进行修改，此时，如果之前编码时，将这些参数解耦到配置资源中，则可以通过修改配置来动态刷新服务配置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit cm rest-service -n system-server</span><br></pre></td></tr></tbody></table></figure><p>在执行这个命令编辑这个服务的配置后，我们可以看到服务的日志信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2021-11-29 07:59:52.860:152 [OkHttp https://10.16.0.1/...] INFO  org.springframework.cloud.kubernetes.config.reload.EventBasedConfigurationChangeDetector -Detected change in config maps</span><br><span class="line">2021-11-29 07:59:52.862:74 [OkHttp https://10.16.0.1/...] INFO  org.springframework.cloud.kubernetes.config.reload.EventBasedConfigurationChangeDetector -Reloading using strategy: REFRESH</span><br><span class="line">2021-11-29 07:59:53.444:112 [OkHttp https://10.16.0.1/...] INFO  org.springframework.cloud.bootstrap.config.PropertySourceBootstrapConfiguration -Located property source: [BootstrapPropertySource {name='bootstrapProperties-configmap.rest-service.system-server'}]</span><br><span class="line">2021-11-29 07:59:53.499:652 [OkHttp https://10.16.0.1/...] INFO  org.springframework.boot.SpringApplication -The following profiles are active: kubernetes,dev</span><br><span class="line">2021-11-29 07:59:53.517:652 [OkHttp https://10.16.0.1/...] INFO  org.springframework.boot.SpringApplication -The following profiles are active: kubernetes,dev</span><br><span class="line">2021-11-29 07:59:53.546:61 [OkHttp https://10.16.0.1/...] INFO  org.springframework.boot.SpringApplication -Started application in 0.677 seconds (JVM running for 968605.422)</span><br><span class="line">2021-11-29 07:59:53.553:61 [OkHttp https://10.16.0.1/...] INFO  org.springframework.boot.SpringApplication -Started application in 0.685 seconds (JVM running for 968617.369)</span><br></pre></td></tr></tbody></table></figure><p>日志中 <strong>Detected change in config maps</strong>、<strong>Reloading using strategy: REFRESH</strong>，表示通过修改配置后达到了自动刷新的效果。</p><p>接下来，我们再看看服务的注册与发现，如果单纯地从 K8s 原生，那其提供了一种域名访问形式来进行服务间的相互调用：<code>$(service name).$(namespace).svc.cluster.local</code>，其中 <strong>cluster.local</strong> 为指定的集群的域名，这里表示本地集群。</p><p>同时，Service 既然是定义一个服务的多种 pod 的逻辑合集以及一种访问 pod 的策略。</p><p>Service 的类型有四种：</p><ul><li>ExternalName：创建一个 DNS 别名指向 service name，这样可以防止 service name 发生变化，但需要配合 DNS 插件使用。</li><li>ClusterIP：默认的类型，用于为集群内 Pod 访问时，提供的固定访问地址,默认是自动分配地址,可使用 ClusterIP 关键字指定固定 IP。</li><li>NodePort：基于 ClusterIp，用于为集群外部访问 Service 后面 Pod 提供访问接入端口。</li><li>LoadBalancer：它是基于 NodePort。</li></ul><p>从上面讲的 Service，我们可以看到一种场景：所有的微服务在一个局域网内，或者说在一个 K8s 集群下，那么可以通过 Service 用于集群内 Pod 的访问，这就是 Service 默认的一种类型 ClusterIP，ClusterIP 这种的默认会自动分配地址。</p><p>那么问题来了，既然可以通过上面的 ClusterIp 来实现集群内部的服务访问，那么如何注册服务呢？其实 K8s 并没有引入任何的注册中心，使用的就是 K8s 的 kube-dns 组件。然后 K8s 将 Service 的名称当做域名注册到 kube-dns 中，每一个 Service 在 kube-dns 中都有一条 DNS 记录，同时，如果有服务的 ip 更换，kube-dns 自动会同步，对服务来说是不需要改动的。通过 Service 的名称就可以访问其提供的服务。那么问题又来了，如果一个服务的 pod 对应有多个，那么如何实现 LB？其实，最终通过 kube-proxy，实现负载均衡。也就是说 kube-dns 通过 servicename 找到指定 clusterIP，kube-proxy 完成通过 clusterIP 到 PodIP 的过程。</p><p>说到这，我们来看下 Service 的服务发现与负载均衡的策略，Service 负载分发策略有两种：</p><ul><li>RoundRobin：轮询模式，即轮询将请求转发到后端的各个 pod 上，其为默认模式。</li><li>SessionAffinity：基于客户端 IP 地址进行会话保持的模式，类似 IP Hash 的方式，来实现服务的负载均衡。</li></ul><p>但这种原生提供的服务访问形式还是带有一点遗憾：就是需要带有 Service 的所在命名空间，这也许 K8s 有其自身的考虑，假如我这里有一个 Service：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: rest-service-service</span><br><span class="line">  namespace: system-server</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - name: rest-svc</span><br><span class="line">    port: 2001</span><br><span class="line">    targetPort: 2001</span><br><span class="line">  selector:</span><br><span class="line">    app: rest-service</span><br></pre></td></tr></tbody></table></figure><p>这个 Service 表示目标是监视 http 协议端口为 2001 的服务的一组 pod，这样，但访问该 Service 时，会通过其域名进行解析到 pod 的信息来访问 pod 的 IP 和 port：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">system-server   rest-service-deployment-cc7c5b559-6t4lp        1/1     Running   6          11d   10.244.0.188    leinao-deploy-server   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">system-server   rest-service-deployment-cc7c5b559-gpg4m        1/1     Running   6          11d   10.244.0.189    leinao-deploy-server   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></tbody></table></figure><p>这样，当我们在容器内通过 <strong>rest-service-service.system-server.svc.cluster.local:2001/api</strong> 访问服务时，这样，我们可以看到默认的类型是 ClusterIP，用于为集群内 Pod 访问时，可以先通过域名来解析到 2 个服务地址信息，然后再通过 LB 策略来选择其中一个作为请求的对象。</p><p>好了，以上就是常见的几种 K8s 资源，当然，还有更多的资源（DaemonSet、StatefulSet、ReplicaSet 等）感兴趣可以参见<a href="https://kubernetes.io/">官网</a>。</p><h3 id="实战-K8s-下微服务的架构实现"><a href="#实战-K8s-下微服务的架构实现" class="headerlink" title="实战 K8s 下微服务的架构实现"></a>实战 K8s 下微服务的架构实现</h3><p>在《<a href="https://gitbook.cn/gitchat/activity/5ebcc95a8902800c0305b38f">Spring Boot 2.x 结合 k8s 实现分布式微服务架构</a>》 Chat 中，我们简单讲述了如何结合 K8s 来实现分布式微服务的架构。</p><p>但这里我们遗留了几个问题：</p><ul><li>Oauth2 高可用的实现</li><li>如何实现跨命名空间的服务的访问</li><li>如何实现分布式服务的灰度、蓝绿发布</li></ul><p>针对以上几点问题，我们来一一破解。</p><h4 id="Oauth2-的高可用实现"><a href="#Oauth2-的高可用实现" class="headerlink" title="Oauth2 的高可用实现"></a>Oauth2 的高可用实现</h4><p>我们知道，对于 Oauth2 原生中，提供了两种方式来进行服务的鉴权：</p><ul><li>获取用户信息来进行鉴权</li><li>通过检验 token 来进行鉴权</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">security:</span><br><span class="line">  path:</span><br><span class="line">    ignores: /,/index,/static/**,/css/**, /image/**, /favicon.ico, /js/**,/plugin/**,/avue.min.js,/img/**,/fonts/**</span><br><span class="line">  oauth2:</span><br><span class="line">    client:</span><br><span class="line">      client-id: rest-service</span><br><span class="line">      client-secret: rest-service-123</span><br><span class="line">      user-authorization-uri: ${cas-server-url}/oauth/authorize</span><br><span class="line">      access-token-uri: ${cas-server-url}/oauth/token</span><br><span class="line">    resource:</span><br><span class="line">      loadBalanced: true</span><br><span class="line">      id: rest-service</span><br><span class="line">      prefer-token-info: true</span><br><span class="line">      token-info-uri: ${cas-server-url}/oauth/check_token</span><br><span class="line">      #user-info-uri: ${cas-server-url}/api/v1/user</span><br><span class="line">    authorization:</span><br><span class="line">      check-token-access: ${cas-server-url}/oauth/check_token</span><br></pre></td></tr></tbody></table></figure><p>配置中，<strong>user-info-uri</strong>、<strong>token-info-uri</strong> 就是用来进行服务客户端的鉴权，但不能同时存在，但对于原生的<strong>user-info-uri</strong>，并没有提供合理的鉴权逻辑，可能存在一些问题：当用户登录后，发现所有的接口都可以正常访问，无论是需要权限的，或者是不需要权限的，<strong>存在一定的问题坑</strong>。</p><p>这里，我们就不再使用获取用户信息方式来进行鉴权、授权。我们来看看<strong>check_token</strong>这种方式是如何进行鉴权授权的呢？</p><p>原来，当用户携带 token 请求资源服务器的资源时, <strong>OAuth2AuthenticationProcessingFilter</strong> 会拦截 token：</p><p><img src="https://files.mdnice.com/user/7503/beb7f133-33b0-41cd-a774-602656d3751b.png"></p><p>最后会进入 loadAuthentication 去进行 token 的检验过程：</p><p><img src="https://files.mdnice.com/user/7503/6b883d40-8d5b-430e-b0c7-7b3f9f0531ca.png"></p><p>至于校验 Token 的处理逻辑很简单，就是调用 redisTokenStore 查询 token 的合法性，及其返回用户的部分信息：</p><p><img src="https://files.mdnice.com/user/7503/2fc7cc1e-3c30-4045-a78d-7e2aec109f77.png"></p><p>最后如果 ok 的话，返回给在这里 RemoteTokenServices，最重要的是 **userTokenConverter.extractAuthentication(map)**，判断是否有 userDetailsService 实现，如果有的话去根据返回的信息查询一次全部的用户信息，没有实现直接返回 username：</p><p><img src="https://files.mdnice.com/user/7503/5dfe403d-1f5e-4cb3-bc82-d845a313514c.png"></p><p>基于此，进行 token 和 userdetails 过程，把无状态的 token 转化成用户信息。</p><p>这样其实还是服务间的互相调用，要保证这种调用的高可用，无非就是服务的多节点、Redis 的高可用。当然如果你是采用 Redis 的话，如果是 JWT 模式，那就更简单了，直接无状态形式存储 Token。我们可以把统一认证中心做成 K8s 中的 Deployment 类型：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: cas-server-deployment</span><br><span class="line">  namespace: system-server</span><br><span class="line">  labels:</span><br><span class="line">    app: cas-server</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: cas-server</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: cas-server</span><br><span class="line">    spec:</span><br><span class="line">      nodeSelector:</span><br><span class="line">        cas-server: "true"</span><br><span class="line">      containers:</span><br><span class="line">      - name: cas-server</span><br><span class="line">        image: {{ cluster_cfg['cluster']['docker-registry']['prefix'] }}cas-server</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        ports:</span><br><span class="line">          - name: cas-server01</span><br><span class="line">            containerPort: 2000</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: /home/cas-server</span><br><span class="line">          name: cas-server-path</span><br><span class="line">        - mountPath: /data/cas-server</span><br><span class="line">          name: cas-server-log-path</span><br><span class="line">        - mountPath: /etc/kubernetes</span><br><span class="line">          name: kube-config-path</span><br><span class="line">        - mountPath: /abnormal_data_dir</span><br><span class="line">          name: abnormal-data-dir</span><br><span class="line">        args: ["sh", "-c", "nohup java $JAVA_OPTS -jar -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m -Xms1024m -Xmx1024m -Xmn256m -Xss256k -XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC cas-server.jar --spring.profiles.active=dev", "&amp;"]</span><br><span class="line">      volumes:</span><br><span class="line">      - name: cas-server-path</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /var/pai/cas-server</span><br><span class="line">      - name: cas-server-log-path</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /data/cas-server</span><br><span class="line">      - name: kube-config-path</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /etc/kubernetes</span><br><span class="line">      - name: abnormal-data-dir</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /data/images/detect_result/defect</span><br></pre></td></tr></tbody></table></figure><p>在这里，我们定义了一个名称为 cas-server-deployment 的资源，同时，我们定义了在创建它的时候，会创建三个副本：<strong>replicas: 3</strong>，这样来保证 cas-server 的高可用。同时，我们为了它更好的被发现，我们利用 Service 资源来进行服务的负载均衡：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: cas-server-service</span><br><span class="line">  namespace: system-server</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: cas-server01</span><br><span class="line">    port: 2000</span><br><span class="line">    targetPort: cas-server01</span><br><span class="line">  selector:</span><br><span class="line">    app: cas-server</span><br></pre></td></tr></tbody></table></figure><p>这里定义的是一个目标为 http 协议，端口为 2000 的 pod 的副本集的资源，这个默认是 ClusterIP 模式的 Service，通过 Service 直接在集群内部进行访问：<strong>cas-server-service.system-server.svc.cluster.local:2000/api</strong>。这样，利用 K8s 的 Service 来实现服务注册与发现。同时，结合 Deployment 资源进行服务多节点的部署，我们就可以实现服务的高可用。</p><h4 id="如何实现跨命名空间的服务的访问"><a href="#如何实现跨命名空间的服务的访问" class="headerlink" title="如何实现跨命名空间的服务的访问"></a>如何实现跨命名空间的服务的访问</h4><p>在 K8s 中，前面讲过，只能通过命名空间的访问方式来请求其它 namespace 下的服务，对于原生 K8s 的服务调用是这样的，但是，我们基于 spring-cloud，这里可以对其进行改造。我们引入 <strong>spring-cloud-k8s</strong> 后，摒弃 基于 Ribbon 的负载均衡，我们采用基于 <strong>spring-cloud-loadbalancer</strong> 的策略来进行尝试:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cas-server</span><br><span class="line">  cloud:</span><br><span class="line">    loadbalancer:</span><br><span class="line">      ribbon:</span><br><span class="line">        enabled: false</span><br><span class="line">    kubernetes:</span><br><span class="line">      ribbon:</span><br><span class="line">        mode: SERVICE</span><br><span class="line">      discovery:</span><br><span class="line">        all-namespaces: true</span><br></pre></td></tr></tbody></table></figure><p>这里有个配置：<strong>spring.cloud.kubernetes.ribbon.mode=SERVICE</strong>，这个是干嘛的呢？其实际是禁用了 Ribbon 的 LB 能力，此时不会生效，走的还是 Spring cloud LoadBalancer。另外对于 Service，这里都设置为 NodePort 类型，如果是默认类型是否可以实现 LB，需要待确认，因为目前来看，没有实现，可能是网络问题，并不是说默认类型的 Service 不可实现 LB。同时，我们还是需要配置：<strong>spring.cloud.loadbalancer.ribbon.enabled = false</strong>，因为这个默认是 true 的。</p><p>当然，这里既然弃用 Ribbon，那需要引入依赖：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-kubernetes-loadbalancer&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure><p>这样，当我们在我们进行资源服务器访问的时候，资源服务器会调用统一认证中心进行 token 的校验，此时，就可以通过 <strong><a href="http://cas-server-service/oauth/check_token">http://cas-server-service/oauth/check_token</a></strong> 来进行检验，这样就实现了服务的高可用。同时，即使资源服务器和统一认证中心不在同一个 namespace，也可以通过该种方式来进行请求访问。具体原理是，其会获取 K8s 集群中所有可被发现的 Service，这样对于不同 namespace 下的 Service 也就存在可以被互调的可能。</p><p>如这里在通过访问 A 命名空间下的服务时，通过 Serice 访问后看到日志：</p><p><img src="https://files.mdnice.com/user/7503/7590c655-76a6-4f0a-8702-8477dceda3d0.png"></p><p>这就说明，可以通过 Service 方式实现<strong>跨命名空间</strong>的服务互调。</p><h4 id="如何实现分布式服务的灰度、蓝绿发布"><a href="#如何实现分布式服务的灰度、蓝绿发布" class="headerlink" title="如何实现分布式服务的灰度、蓝绿发布"></a>如何实现分布式服务的灰度、蓝绿发布</h4><p>在云原生最佳实践中，涵盖了<strong>灰度发布</strong>、弹性伸缩、集群迁移、网络通信、应用容器化改造等等场景，今天我们就来利用 K8s 原生技术来实现分布式微服务的<strong>灰度发布</strong>以及<strong>蓝绿发布</strong>。</p><p>通常使用无状态负载 Deployment、有状态负载 StatefulSet 等 Kubernetes 对象来部署业务，每个工作负载管理一组 Pod。以 Deployment 为例，示意图如下：</p><p><img src="https://files.mdnice.com/user/7503/cb98f882-9091-4bc1-8200-46dcdb0cbd4d.png"></p><p>我们为这个工作服务来创建 Service，Service 通过 selector 来选择服务节点 Pod，接下来，我们进行灰度发布该工作应用负载。</p><h5 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h5><p>通常会为每个 Deployment 类型的应用负载创建一个 Service，但 K8s 并未限制 Service 需与 Deployment 负载是一一对应关系。Service 只通过 selector 匹配负载节点 Pod，若不同 Deployment 的负载节点 Pod 被同一 selector 选中，即可实现一个 Service 对应多个版本 Deployment。调整不同版本 Deployment 的副本数，即可调整不同版本服务的权重，来实现灰度发布。</p><p>那么，既然了解到灰度发布的原理，我们来进行实战，假如这里有一个服务提供者 diss-ns-service，此时我们可以对其进行创建不同版本的 Deployment 类型负载 Pod：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: diff-ns-service-v1-deployment</span><br><span class="line">  namespace: ns-app</span><br><span class="line">  labels:</span><br><span class="line">    app: diff-ns-service</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: diff-ns-service</span><br><span class="line">      version: v1</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: diff-ns-service</span><br><span class="line">        version: v1</span><br><span class="line">    spec:</span><br><span class="line">      nodeSelector:</span><br><span class="line">        diff-ns-service: "true"</span><br><span class="line">      containers:</span><br><span class="line">      - name: diff-ns-service</span><br><span class="line">        image: diff-ns-service:v1</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        ports:</span><br><span class="line">          - name: diff-ns</span><br><span class="line">            containerPort: 2001</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: /home/diff-ns-service</span><br><span class="line">          name: diff-ns-service-path</span><br><span class="line">        - mountPath: /data/diff-ns-service</span><br><span class="line">          name: diff-ns-service-log-path</span><br><span class="line">        - mountPath: /etc/kubernetes</span><br><span class="line">          name: kube-config-path</span><br><span class="line">        - mountPath: /abnormal_data_dir</span><br><span class="line">          name: abnormal-data-dir</span><br><span class="line">        args: ["sh", "-c", "nohup java $JAVA_OPTS -jar -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m -Xms1024m -Xmx1024m -Xmn256m -Xss256k -XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC diff-ns-service.jar --spring.profiles.active=dev", "&amp;"]</span><br><span class="line">      volumes:</span><br><span class="line">      - name: diff-ns-service-path</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /var/pai/diff-ns-service</span><br><span class="line">      - name: diff-ns-service-log-path</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /data/diff-ns-service</span><br><span class="line">      - name: kube-config-path</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /etc/kubernetes</span><br><span class="line">      - name: abnormal-data-dir</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /data/images/detect_result/defect</span><br></pre></td></tr></tbody></table></figure><p>以上是 v1 版本的应用负载，接下来 v2 版本也是一样的：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: diff-ns-service-v2-deployment</span><br><span class="line">  namespace: ns-app</span><br><span class="line">  labels:</span><br><span class="line">    app: diff-ns-service</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: diff-ns-service</span><br><span class="line">      version: v2</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: diff-ns-service</span><br><span class="line">        version: v2</span><br><span class="line">    spec:</span><br><span class="line">      nodeSelector:</span><br><span class="line">        diff-ns-service: "true"</span><br><span class="line">      containers:</span><br><span class="line">      - name: diff-ns-service</span><br><span class="line">        image: diff-ns-service:v2</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        ports:</span><br><span class="line">          - name: diff-ns</span><br><span class="line">            containerPort: 2001</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: /home/diff-ns-service</span><br><span class="line">          name: diff-ns-service-path</span><br><span class="line">        - mountPath: /data/diff-ns-service</span><br><span class="line">          name: diff-ns-service-log-path</span><br><span class="line">        - mountPath: /etc/kubernetes</span><br><span class="line">          name: kube-config-path</span><br><span class="line">        - mountPath: /abnormal_data_dir</span><br><span class="line">          name: abnormal-data-dir</span><br><span class="line">        args: ["sh", "-c", "nohup java $JAVA_OPTS -jar -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m -Xms1024m -Xmx1024m -Xmn256m -Xss256k -XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC diff-ns-service.jar --spring.profiles.active=dev", "&amp;"]</span><br><span class="line">      volumes:</span><br><span class="line">      - name: diff-ns-service-path</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /var/pai/diff-ns-service</span><br><span class="line">      - name: diff-ns-service-log-path</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /data/diff-ns-service</span><br><span class="line">      - name: kube-config-path</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /etc/kubernetes</span><br><span class="line">      - name: abnormal-data-dir</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /data/images/detect_result/defect</span><br></pre></td></tr></tbody></table></figure><p>同时，这里我们对负载的副本数都设置为 3，表示 3 个负载节点 pod，此时，我们创建完之后可以看到：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ns-app          diff-ns-service-v1-deployment-d88b9c4fd-22lgb     1/1     Running   0          12s</span><br><span class="line">ns-app          diff-ns-service-v1-deployment-d88b9c4fd-cgsqw     1/1     Running   0          12s</span><br><span class="line">ns-app          diff-ns-service-v1-deployment-d88b9c4fd-hmcbq     1/1     Running   0          12s</span><br><span class="line"></span><br><span class="line">ns-app          diff-ns-service-v2-deployment-37bf53d4b-43w23     1/1     Running   0          12s</span><br><span class="line">ns-app          diff-ns-service-v2-deployment-37bf53d4b-ce33g     1/1     Running   0          12s</span><br><span class="line">ns-app          diff-ns-service-v2-deployment-37bf53d4b-scds6     1/1     Running   0          12s</span><br></pre></td></tr></tbody></table></figure><p>这样，我们对负载 diff-ns-service 创建了不同版本的资源 Pod，接下来，我们创建一个 Service，这个是这样的 YAML：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: diff-ns-service-service</span><br><span class="line">  namespace: ns-app</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: diff-ns-svc</span><br><span class="line">    port: 2001</span><br><span class="line">    targetPort: 2001</span><br><span class="line">  selector:</span><br><span class="line">    app: diff-ns-service</span><br></pre></td></tr></tbody></table></figure><p>我们可以看到在 selector 中不指定版本，这样，可以让 Service 同时选中两个版本的 Deployment 的 Pod。此时，我们通过脚本命令来执行访问：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in {1..10}; do curl http://diff-ns-service-service/getservicedetail?servicename=aaa; done;</span><br></pre></td></tr></tbody></table></figure><p>我们来看看打印的日志：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">diff-ns-service-v1</span><br><span class="line">diff-ns-service-v2</span><br><span class="line">diff-ns-service-v1</span><br><span class="line">diff-ns-service-v2</span><br><span class="line">diff-ns-service-v1</span><br><span class="line">diff-ns-service-v2</span><br><span class="line">diff-ns-service-v1</span><br><span class="line">diff-ns-service-v2</span><br><span class="line">diff-ns-service-v1</span><br><span class="line">diff-ns-service-v2</span><br></pre></td></tr></tbody></table></figure><p>可以看到返回结果一半为 v1 版本的响应，一半为 v2 版本的响应。</p><p>接下来，我们通过 kubectl 方式修改负载的副本数：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale deployment/diff-ns-service-v2-deployment --replicas=4</span><br><span class="line"></span><br><span class="line">kubectl scale deployment/diff-ns-service-v1-deployment --replicas=1</span><br></pre></td></tr></tbody></table></figure><p>因为我们需要作版本的更新，所以把新版本 v2 设置为 4，旧版本 v1 的设置为 1，接下来，我们继续通过 curl 命令来测试：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">diff-ns-service-v2</span><br><span class="line">diff-ns-service-v2</span><br><span class="line">diff-ns-service-v1</span><br><span class="line">diff-ns-service-v2</span><br><span class="line">diff-ns-service-v1</span><br><span class="line">diff-ns-service-v2</span><br><span class="line">diff-ns-service-v2</span><br><span class="line">diff-ns-service-v2</span><br><span class="line">diff-ns-service-v2</span><br><span class="line">diff-ns-service-v2</span><br></pre></td></tr></tbody></table></figure><p>我们从结果可以发现，10 次请求访问中，只有 2 次访问的是 v1 的旧版本，v1 与 v2 版本的响应比例与其副本数比例一致，为 4:1。通过控制不同版本服务的副本数就实现了灰度发布。</p><h5 id="蓝绿发布"><a href="#蓝绿发布" class="headerlink" title="蓝绿发布"></a>蓝绿发布</h5><p>接下来看看蓝绿发布，蓝绿发布的原理与灰度发布稍微不同，集群中已部署两个不同版本的 Deployment，其负载 Pod 拥有共同的 label。但有一个 label 值不同，用于区分不同的版本。Service 使用 selector 选中了其中一个版本的 Deployment 的 Pod，此时通过修改 Service 的 selector 中决定服务版本的 label 的值来改变 Service 后端对应的 Pod，即可实现让服务从一个版本直接切换到另一个版本。</p><p>所以从原理上看，我们创建的 Service 除了包括本身的一些信息，还需要包括版本信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: diff-ns-service-service</span><br><span class="line">  namespace: ns-app</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: diff-ns-svc</span><br><span class="line">    port: 2001</span><br><span class="line">    targetPort: 2001</span><br><span class="line">  selector:</span><br><span class="line">    app: diff-ns-service</span><br><span class="line">    version: v1</span><br></pre></td></tr></tbody></table></figure><p>同样，执行以下命令，测试访问。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in {1..10}; do curl http://diff-ns-service-service/getservicedetail?servicename=aaa; done;</span><br></pre></td></tr></tbody></table></figure><p>返回结果如下，均为 v1 版本的响应：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">diff-ns-service-v1</span><br><span class="line">diff-ns-service-v1</span><br><span class="line">diff-ns-service-v1</span><br><span class="line">diff-ns-service-v1</span><br><span class="line">diff-ns-service-v1</span><br><span class="line">diff-ns-service-v1</span><br><span class="line">diff-ns-service-v1</span><br><span class="line">diff-ns-service-v1</span><br><span class="line">diff-ns-service-v1</span><br><span class="line">diff-ns-service-v1</span><br></pre></td></tr></tbody></table></figure><p>我们通过 kubectl 方式修改 Service 的 label：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl patch service diff-ns-service-service -p '{"spec":{"selector":{"version":"v2"}}}'</span><br></pre></td></tr></tbody></table></figure><p>再次，执行以下命令，测试访问。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in {1..10}; do curl http://diff-ns-service-service/getservicedetail?servicename=aaa; done;</span><br></pre></td></tr></tbody></table></figure><p>返回结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">diff-ns-service-v2</span><br><span class="line">diff-ns-service-v2</span><br><span class="line">diff-ns-service-v2</span><br><span class="line">diff-ns-service-v2</span><br><span class="line">diff-ns-service-v2</span><br><span class="line">diff-ns-service-v2</span><br><span class="line">diff-ns-service-v2</span><br><span class="line">diff-ns-service-v2</span><br><span class="line">diff-ns-service-v2</span><br><span class="line">diff-ns-service-v2</span><br></pre></td></tr></tbody></table></figure><p>结果均为 v2 版本的响应，成功实现了蓝绿发布。</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><h4 id="云原生技术与微服务架构的天衣无缝"><a href="#云原生技术与微服务架构的天衣无缝" class="headerlink" title="云原生技术与微服务架构的天衣无缝"></a>云原生技术与微服务架构的天衣无缝</h4><p>云原生的微服务架构是云原生技术和微服务架构的完美结合。微服务作为一种架构风格，所解决的问题是交纵复杂的软件系统的架构与设计；云原生技术乃一种实现方式，所解决的问题是软件系统的运行、维护和治理。微服务架构可以选择不同的实现方式，如 Java 中的 Dubbo、Spring Cloud、Spring Cloud Alibaba，Golang 中的 Beego，Python 中的 Flask 等。但这些不同语言的服务之间的访问与运行可能存在一定得困难性与复杂性。但，云原生和微服务架构的结合，使得它们相得益彰。这其中的原因在于：云原生技术可以有效地弥补微服务架构所带来的实现上的复杂度；微服务架构难以落地的一个重要原因是它过于复杂，对开发团队的组织管理、技术水平和运维能力都提出了极高的要求。因此，一直以来只有少数技术实力雄厚的大企业会采用微服务架构。随着云原生技术的流行，在弥补了微服务架构的这一个短板之后，极大地降低了微服务架构实现的复杂度，使得广大的中小企业有能力在实践中应用微服务架构。云原生技术促进了微服务架构的推广，也是微服务架构落地的最佳搭配。</p><h4 id="云原生时代的微服务的未来"><a href="#云原生时代的微服务的未来" class="headerlink" title="云原生时代的微服务的未来"></a>云原生时代的微服务的未来</h4><p>云原生的第一个发展趋势：标准化和规范化，该技术的基础是容器化和容器编排技术，最经常会用到的技术是 Kubernetes 和 Docker 等。随着云原生技术的发展，云原生技术的标准化和规范化工作正在不断推进，其目的是促进技术的发展和避免供应商锁定的问题，这对于整个云原生技术的生态系统是至关重要的。</p><p>云原生的第二个发展趋势：平台化，以服务网格技术为代表，这一趋势的出发点是增强云平台的能力，从而降低运维的复杂度。流量控制、身份认证和访问控制、性能指标数据收集、分布式服务追踪和集中式日志管理等功能，都可以由底层平台来提供，这就极大地降低了中小企业在运行和维护云原生应用时的复杂度，服务网格以 Istio 和 Linkerd 为开源代表。</p><p>云原生的第三个发展趋势：应用管理技术的进步，如在 Kubernetes 平台上部署和更新应用一直以来都比较复杂，传统的基于资源声明 YAML 文件的做法，已经逐步被 Helm 所替代。操作员模式在 Helm 的基础上更进一步，以更高效、自动化和可扩展的方式对应用部署进行管理。</p><br><br><p><span class="suffix" style="display: none;"></span></p><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码:</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;">https://gitee.com/damon_one/spring-cloud-k8s</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">交个朋友之猿天地</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://xiao8.github.io" style="text-decoration: none" title="">交个朋友之猿天地 | 微服务 | 容器化 | 自动化</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：交个朋友之猿天地"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="后端" scheme="http://xiao8.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="云原生" scheme="http://xiao8.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    <category term="微服务架构" scheme="http://xiao8.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Springboot 升级到 2.6.1 的坑</title>
    <link href="http://xiao8.github.io/2021/12/14/springboot-2-6-x/"/>
    <id>http://xiao8.github.io/2021/12/14/springboot-2-6-x/</id>
    <published>2021-12-14T07:46:48.000Z</published>
    <updated>2021-12-16T02:23:14.447Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="SpringBoot-2-6-0-重磅发布"><a href="#SpringBoot-2-6-0-重磅发布" class="headerlink" title="SpringBoot 2.6.0 重磅发布"></a>SpringBoot 2.6.0 重磅发布</h2><h3 id="重要特性"><a href="#重要特性" class="headerlink" title="重要特性"></a>重要特性</h3><h4 id="1-Servlet-应用支持在-Cookie-中配置-SameSite-属性"><a href="#1-Servlet-应用支持在-Cookie-中配置-SameSite-属性" class="headerlink" title="1. Servlet 应用支持在 Cookie 中配置 SameSite 属性"></a>1. Servlet 应用支持在 Cookie 中配置 SameSite 属性</h4><p>该属性可通过 server.session.cookie.same-site 属性来配置，共有三个可选值：</p><ul><li>Strict 严格模式，必须同站请求才能发送 cookie</li><li>Lax 宽松模式，安全的跨站请求可以发送 cookie</li><li>None 禁止 SameSite 限制，必须配合 Secure 一起使用</li></ul><h4 id="2-支持为主应用端口和管理端口配置健康组"><a href="#2-支持为主应用端口和管理端口配置健康组" class="headerlink" title="2. 支持为主应用端口和管理端口配置健康组"></a>2. 支持为主应用端口和管理端口配置健康组</h4><p>这在 Kubernetes 等云服务环境中很有用。在这种环境下，出于安全目的，为执行器端点使用单独的管理端口是很常见的。拥有单独的端口可能会导致不可靠的健康检查，因为即使健康检查成功，主应用程序也可能无法正常工作。</p><p>以往传统的配置会将所有 Actuator 端点都放在一个单独的端口上，并将用于检测应用状态的健康组放在主端口的附加路径下。</p><h4 id="3-增强-info-端点，加入-Java-Runtime-信息"><a href="#3-增强-info-端点，加入-Java-Runtime-信息" class="headerlink" title="3. 增强/info 端点，加入 Java Runtime 信息"></a>3. 增强/info 端点，加入 Java Runtime 信息</h4><p>增强后的例子：</p><pre class="line-numbers language-none"><code class="language-none">{  "java": {    "vendor": "BellSoft",    "version": "17",    "runtime": {      "name": "OpenJDK Runtime Environment",      "version": "17+35-LTS"    },    "jvm": {      "name": "OpenJDK 64-Bit Server VM",      "vendor": "BellSoft",      "version": "17+35-LTS"    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该信息可以通过这个属性开启或关闭：</p><pre class="line-numbers language-none"><code class="language-none">management.info.java.enabled=true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-支持使用-WebTestClient-来测试-Spring-MVC"><a href="#4-支持使用-WebTestClient-来测试-Spring-MVC" class="headerlink" title="4. 支持使用 WebTestClient 来测试 Spring MVC"></a>4. 支持使用 WebTestClient 来测试 Spring MVC</h4><p>开发人员可以使用 WebTestClient 在模拟环境中测试 WebFlux 应用程序，或针对实时服务器测试任何 Spring Web 应用程序。</p><p>这次增强后，开发者可以在 Mock 环境中使用 @AutoConfigureMockMvc 注释的类，就可以轻松注入 WebTestClient。 这样编写测试就比之前容易多了。</p><h4 id="5-增加-spring-rabbit-stream-的自动化配置"><a href="#5-增加-spring-rabbit-stream-的自动化配置" class="headerlink" title="5. 增加 spring-rabbit-stream 的自动化配置"></a>5. 增加 spring-rabbit-stream 的自动化配置</h4><p>这次更新添加了 Spring AMQP 的新 spring-rabbit-stream 模块的自动配置。</p><p>当 spring.rabbitmq.listener.type 属性设置为 stream 时， StreamListenerContainer 是自动配置的。</p><pre class="line-numbers language-none"><code class="language-none">spring.rabbitmq.stream.*属性可用于配置对broker的访问，spring.rabbitmq.listener.stream.native-listener 可用于启用native listener<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="6-支持-env-端点和-configprops-配置属性的自定义脱敏"><a href="#6-支持-env-端点和-configprops-配置属性的自定义脱敏" class="headerlink" title="6. 支持/env 端点和 configprops 配置属性的自定义脱敏"></a>6. 支持/env 端点和 configprops 配置属性的自定义脱敏</h4><p>虽然 Spring Boot 之前已经可以处理 /env 和 /configprops 端点中存在的敏感值，只需要可以通过配置属性来控制即可。但还有一种情况，用户可能希望根据属性源自哪个 PropertySource 来应用清理。</p><p>例如，Spring Cloud Vault 使用 Vault 来存储加密值并将它们加载到 Spring 环境中。由于所有值都是加密的，因此将整个属性源中的每个键的值脱敏是有意义的。可以通过添加类型为 SanitizingFunction 的 @Bean 来配置此类自定义脱敏规则。</p><p>顺手推荐一下我一直在连载的免费教程：Spring Boot 教程可以点击直达！。</p><p>跟很多其他教程不同。这个教程不光兼顾了 1.x 和 2.x 版本。同时，对于每次的更新，都会选择一些相关内容修补 Tips，所以对各种不同阶段的读者长期都会有一些收获。如果你觉得不错，记得转发支持一下！</p><p>同时，如果你对哪方面还有疑惑，或希望 DD 多做些什么例子到教程里，也欢迎留言催更，或点赞支持别人的催更内容！</p><h4 id="其他变更"><a href="#其他变更" class="headerlink" title="其他变更"></a>其他变更</h4><h5 id="1-Reactive-Session-个性化"><a href="#1-Reactive-Session-个性化" class="headerlink" title="1. Reactive Session 个性化"></a>1. Reactive Session 个性化</h5><p>当前版本可以动态配置 reactive session 的有效期</p><pre class="line-numbers language-none"><code class="language-none">server.reactive.session.timeout=30<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-Redis-链接自动配置链接池"><a href="#2-Redis-链接自动配置链接池" class="headerlink" title="2. Redis 链接自动配置链接池"></a>2. Redis 链接自动配置链接池</h5><p>当应用依赖中包含 commons-pool2.jar 会自动配置 redis 链接池 （Jedis Lettuce 都支持）。如果你想关闭则通过如下属性：</p><pre class="line-numbers language-none"><code class="language-none">spring.redis.jedis.pool.enabled=falsespring.redis.lettuce.pool.enabled=false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h6 id="3-构建信息个性化"><a href="#3-构建信息个性化" class="headerlink" title="3. 构建信息个性化"></a>3. 构建信息个性化</h6><p>通过 spring-boot-maven-plugin 支持自动生成此次构建信息的 build-info.properties</p><pre class="line-numbers language-none"><code class="language-none">&lt;plugin&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;  &lt;configuration&gt;       &lt;excludeInfoProperties&gt;        &lt;excludeInfoProperty&gt;version&lt;/excludeInfoProperty&gt;     &lt;/excludeInfoProperties&gt;  &lt;/configuration&gt;&lt;/plugin&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-Metrics-新增指标"><a href="#4-Metrics-新增指标" class="headerlink" title="4. Metrics 新增指标"></a>4. Metrics 新增指标</h5><p>应用启动的两个新指标：</p><pre class="line-numbers language-none"><code class="language-none">application.started.time: 启动应用程序所需的时间application.ready.time:  启动应用到对外提供服务所需时间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>磁盘空间的两个指标：</p><pre class="line-numbers language-none"><code class="language-none">disk.free： 磁盘空闲空间disk.total： 磁盘总空间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="5-Docker-镜像的构建"><a href="#5-Docker-镜像的构建" class="headerlink" title="5. Docker 镜像的构建"></a>5. Docker 镜像的构建</h5><p>增强 docker-maven-plugin 插件的功能：</p><ul><li>为自定义镜像设置 tags 标签</li><li>网络配置参数，可用于 Cloud Native Buildpacks 的构建过程</li><li>支持使用 buildCache 和 launchCache 配置参数自定义用于缓存层的名称，这些层由构建包提供给构建的镜像</li></ul><h6 id="6-移除-2-4-版本中的过期属性"><a href="#6-移除-2-4-版本中的过期属性" class="headerlink" title="6. 移除 2.4 版本中的过期属性"></a>6. 移除 2.4 版本中的过期属性</h6><p>由于 2.4 版本完成历史使命，因此有大量过期属性被移除，最近要升级的小伙伴一定要关注一下这部分内容，因为你原来的配置会失效！</p><p>因为内容较多，这里就不完全贴出来了，有兴趣的可以看看文末参考资料中的官方信息。</p><h5 id="7-默认情况完全禁止-Bean-的循环引用"><a href="#7-默认情况完全禁止-Bean-的循环引用" class="headerlink" title="7. 默认情况完全禁止 Bean 的循环引用"></a>7. 默认情况完全禁止 Bean 的循环引用</h5><p>在 2.6.0 之后，默认禁止了循环引用，如果你的项目出现循环引用，会进行报错：</p><pre class="line-numbers language-none"><code class="language-none">The dependencies of some of the beans in the application context form a cycle:   authorizationServerConfig (field private org.springframework.security.crypto.password.PasswordEncoder com.leinao.config.AuthorizationServerConfig.passwordEncoder)      ↓   securityConfig      ↓   org.springframework.web.servlet.config.annotation.DelegatingWebMvcConfiguration┌─────┐|  com.alibaba.cloud.sentinel.SentinelWebAutoConfiguration (field private java.util.Optional com.alibaba.cloud.sentinel.SentinelWebAutoConfiguration.sentinelWebInterceptorOptional)└─────┘Action:Relying upon circular references is discouraged and they are prohibited by default. Update your application to remove the dependency cycle between beans. As a last resort, it may be possible to break the cycle automatically by setting spring.main.allow-circular-references to true.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里对阿里巴巴的 Sentinel 进行了循环引用，导致出现错误。</p><p>当然，可能这样的要求对于开发者会很痛苦。所以，你也可以通过下面的配置，放开不允许循环依赖的要求：</p><pre class="line-numbers language-none"><code class="language-none">spring.main.allow-circular-references=true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="8-SpringMVC-默认路径匹配策略"><a href="#8-SpringMVC-默认路径匹配策略" class="headerlink" title="8. SpringMVC 默认路径匹配策略"></a>8. SpringMVC 默认路径匹配策略</h5><p>Spring MVC 处理程序映射匹配请求路径的默认策略已从 AntPathMatcher 更改为 PathPatternParser。</p><p>Actuator 端点现在也使用基于 PathPattern 的 URL 匹配。需要注意的是，Actuator 端点的路径匹配策略无法通过配置属性进行配置。</p><p>如果需要将默认切换回 AntPathMatcher，可以将 spring.mvc.pathmatch.matching-strategy 设置为 ant-path-matcher，比如下面这样：</p><pre class="line-numbers language-none"><code class="language-none">spring.mvc.pathmatch.matching-strategy=ant-path-matcher<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="springboot-2-6-1"><a href="#springboot-2-6-1" class="headerlink" title="springboot 2.6.1"></a>springboot 2.6.1</h2><p>11 月 29 日 Spring Boot 2.6.1 正式发布，主要是为了支持本周即将发布的 Spring Cloud 2021，此版本包括 11 个错误修复和文档改进。</p><h3 id="Bug-修复"><a href="#Bug-修复" class="headerlink" title="Bug 修复"></a>Bug 修复</h3><ul><li>模式分析 PatternParseException 的操作消息中的 matching-strategy 属性的名称不正确#28839</li><li>修复 ErrorPageSecurityFilter 部署到 Servlet 3.1 的兼容问题#28790</li><li>QuartzDataSourceScriptDatabaseInitiializer 不提供 MariaDB #28779 的映射</li><li>“test” 和 “Inlined Test Properties” 属性源顺序不正确#28776</li><li>在没有 spring-security-web 的 Servlet 应用程序中使用 Spring Security 时出现 ArrayStoreException #28774</li><li>DefaultClientResources 在将 Lettuce 与 Actuator 一起使用时未正确关闭是发出警告 #28767</li><li>具有 permitAll 的页面无法再通过自动配置的 MockMvc #28759</li><li>依赖管理 org.elasticsearch.distribution.integ-test-zip:elasticsearch 应将其类型声明为 zip #28746</li></ul><h3 id="修复文档"><a href="#修复文档" class="headerlink" title="修复文档"></a>修复文档</h3><ul><li>修复文档 “External Application Properties” 部分中的拼写错误 #28834</li><li>修复参考文档 #28833 中 “spring –version” 的输出。</li><li>org.springframework.boot.actuate.metrics.data 包添加描述 #28761。</li></ul><h2 id="升级-spring-cloud-k8s"><a href="#升级-spring-cloud-k8s" class="headerlink" title="升级 spring-cloud-k8s"></a>升级 spring-cloud-k8s</h2><h3 id="服务提供者（SSO）"><a href="#服务提供者（SSO）" class="headerlink" title="服务提供者（SSO）"></a>服务提供者（SSO）</h3><p>首先引入高版本：</p><pre class="line-numbers language-none"><code class="language-none">&lt;parent&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;      &lt;version&gt;2.6.1&lt;/version&gt;      &lt;relativePath/&gt;  &lt;/parent&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，我们看看 cloud 如何接入 k8s，这里已经发生重大改变：</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependencyManagement&gt;&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;&lt;version&gt;2021.0.0&lt;/version&gt;&lt;type&gt;pom&lt;/type&gt;&lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt;&lt;/dependencies&gt;&lt;/dependencyManagement&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>cloud 我们引入最新版本 2021.0.0，接下来，我们看看 k8s 部分依赖：</p><pre class="line-numbers language-none"><code class="language-none">  &lt;dependency&gt;     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;     &lt;artifactId&gt;spring-cloud-starter-kubernetes-fabric8-config&lt;/artifactId&gt;  &lt;/dependency&gt;&lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-commons&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-kubernetes-fabric8-discovery&lt;/artifactId&gt;    &lt;/dependency&gt;  &lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-starter-kubernetes-fabric8-loadbalancer&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;&lt;artifactId&gt;okhttp&lt;/artifactId&gt;&lt;version&gt;${okhttp.version}&lt;/version&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里发生改变的是，之前引入的是直接对 k8s 的，这里是关于 fabric8 第三方的注入。</p><p>引入完这些后，我们接下来看关于 Oauth2 的使用，之前引入的是：</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;     &lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这种通过注解方式来处理，但在 spring cloud2021 版本中，已经摒弃了这种方式，统一归纳到 spring-cloud-common，这里为了解决这种问题使用以下依赖：</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;&lt;groupId&gt;org.springframework.security.oauth.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-security-oauth2-autoconfigure&lt;/artifactId&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>服务提供者目前未出现任何严重问题，我们打包部署下：</p><p><img src="https://gitee.com/damon_one/picture/raw/master/2021-12-14/1639465751944-1639465743(1).png"></p><p>看到上面的日志，表明已经部署成功。</p><h3 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h3><p>同样引入你那些版本依赖，如上面的服务提供者一样，同时，也需要引入：</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;&lt;groupId&gt;org.springframework.security.oauth.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-security-oauth2-autoconfigure&lt;/artifactId&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以实现 SSO，目前看到未出现任何问题，接下来，我们需要去部署：</p><p><img src="https://gitee.com/damon_one/picture/raw/master/2021-12-14/1639465970572-image.png"></p><p>部署完后，发现报以上的错，经过各种尝试发现是与 swagger 的兼容，这里直接尝试：修复方法：注解 <code>EnableSwagger2</code> 改为 <code>EnableWebMvc</code>:</p><p><img src="https://gitee.com/damon_one/picture/raw/master/2021-12-14/1639466191890-image.png"></p><p>同时，我们发现下面的红色部分会出现问题，因为是改变了函数参数，修改为红色部分即可。</p><p>最后，我们再次启动，发现完美开启，升级成功。</p><p>PS：springboot高版本结合alibaba，目前发现一些问题，暂时不提供升级。待后续。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="后端" scheme="http://xiao8.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="后端" scheme="http://xiao8.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Log4j 史诗级漏洞来袭，已引起大规模入侵</title>
    <link href="http://xiao8.github.io/2021/12/10/log4j2/"/>
    <id>http://xiao8.github.io/2021/12/10/log4j2/</id>
    <published>2021-12-10T05:58:04.000Z</published>
    <updated>2021-12-10T06:02:02.098Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>Apache Log4j2 是一个基于 Java 的日志记录工具。该工具重写了 Log4j 框架，并且引入了大量丰富的特性。该日志框架被大量用于业务系统开发，用来记录日志信息。</p><p>在大多数情况下，开发者可能会将用户输入导致的错误信息写入日志中。攻击者利用此特性可通过该漏洞构造特殊的数据请求包，最终触发远程代码执行。由于该漏洞影响范围极广，建议广大用户及时排查相关漏洞，经过白帽汇安全研究院分析确认，目前市面有多款流行的系统都受影响。</p><h4 id="该漏洞危害等级：严重"><a href="#该漏洞危害等级：严重" class="headerlink" title="该漏洞危害等级：严重"></a>该漏洞危害等级：严重</h4><h3 id="1、漏洞简介"><a href="#1、漏洞简介" class="headerlink" title="1、漏洞简介"></a>1、漏洞简介</h3><p>Apache Log4j 2是一款优秀的Java日志框架。该工具重写了Log4j框架，并且引入了大量丰富的特性。该日志框架被大量用于业务系统开发，用来记录日志信息。由于Apache Log4j 2某些功能存在递归解析功能，攻击者可直接构造恶意请求，触发远程代码执行漏洞。</p><h3 id="2、漏洞危害"><a href="#2、漏洞危害" class="headerlink" title="2、漏洞危害"></a>2、漏洞危害</h3><p>漏洞利用无需特殊配置，攻击者可直接构造恶意请求，触发远程代码执行漏洞。</p><h3 id="3、漏洞编号"><a href="#3、漏洞编号" class="headerlink" title="3、漏洞编号"></a>3、漏洞编号</h3><p>暂无</p><h3 id="4、影响范围"><a href="#4、影响范围" class="headerlink" title="4、影响范围"></a>4、影响范围</h3><p>Apache Log4j 2.x &lt;= 2.14.1</p><h3 id="5、修复措施"><a href="#5、修复措施" class="headerlink" title="5、修复措施"></a>5、修复措施</h3><p>建议排查Java应用是否引入log4j-api , log4j-core 两个jar，若存在使用，极大可能会受到影响，强烈建议受影响用户尽快进行防护 。升级Apache Log4j 2所有相关应用到最新的 log4j-2.15.0-rc1 版本，地址：<a href="https://github.com/apache/logging-log4j2/releases/tag/log4j-2.15.0-rc2">https://github.com/apache/logging-log4j2/releases/tag/log4j-2.15.0-rc2</a></p><p>升级已知受影响的应用及组件，如：</p><ul><li>spring-boot-strater-log4j2</li><li>Apache Solr</li><li>Apache Flink</li><li>Apache Druid</li></ul><h3 id="6、紧急缓解措施："><a href="#6、紧急缓解措施：" class="headerlink" title="6、紧急缓解措施："></a>6、紧急缓解措施：</h3><p>如果还来不及更新版本修复，可通过下面的方法紧急缓解问题</p><ul><li><p>修改jvm参数 -Dlog4j2.formatMsgNoLookups=true</p></li><li><p>修改配置：log4j2.formatMsgNoLookups=True</p></li><li><p>将系统环境变量 FORMAT_MESSAGES_PATTERN_DISABLE_LOOKUPS 设置为 true</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="后端" scheme="http://xiao8.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://xiao8.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>云原生基础架构K8s实践Chat(填坑、实战版)</title>
    <link href="http://xiao8.github.io/2021/12/06/cloud-native-k8s/"/>
    <id>http://xiao8.github.io/2021/12/06/cloud-native-k8s/</id>
    <published>2021-12-06T07:58:32.000Z</published>
    <updated>2021-12-06T08:30:05.447Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="旧时代的微服务"><a href="#旧时代的微服务" class="headerlink" title="旧时代的微服务"></a>旧时代的微服务</h2><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><h3 id="多模块"><a href="#多模块" class="headerlink" title="多模块"></a>多模块</h3><h3 id="组件化太多"><a href="#组件化太多" class="headerlink" title="组件化太多"></a>组件化太多</h3><h3 id="微服务太杂"><a href="#微服务太杂" class="headerlink" title="微服务太杂"></a>微服务太杂</h3><h3 id="难以部署，部署困难"><a href="#难以部署，部署困难" class="headerlink" title="难以部署，部署困难"></a>难以部署，部署困难</h3><h3 id="手动运维"><a href="#手动运维" class="headerlink" title="手动运维"></a>手动运维</h3><h3 id="维护复杂、烧脑"><a href="#维护复杂、烧脑" class="headerlink" title="维护复杂、烧脑"></a>维护复杂、烧脑</h3><h2 id="新时代的基础架构"><a href="#新时代的基础架构" class="headerlink" title="新时代的基础架构"></a>新时代的基础架构</h2><h3 id="基础架构新模式K8s"><a href="#基础架构新模式K8s" class="headerlink" title="基础架构新模式K8s"></a>基础架构新模式K8s</h3><h3 id="实现分布式配置化"><a href="#实现分布式配置化" class="headerlink" title="实现分布式配置化"></a>实现分布式配置化</h3><h3 id="实现分布式微服务部署"><a href="#实现分布式微服务部署" class="headerlink" title="实现分布式微服务部署"></a>实现分布式微服务部署</h3><h3 id="实现实时监控"><a href="#实现实时监控" class="headerlink" title="实现实时监控"></a>实现实时监控</h3><h3 id="实现分布式、高可用、自启动"><a href="#实现分布式、高可用、自启动" class="headerlink" title="实现分布式、高可用、自启动"></a>实现分布式、高可用、自启动</h3><h3 id="实现实时动态更新配置"><a href="#实现实时动态更新配置" class="headerlink" title="实现实时动态更新配置"></a>实现实时动态更新配置</h3><h3 id="实现千万服务统一管理"><a href="#实现千万服务统一管理" class="headerlink" title="实现千万服务统一管理"></a>实现千万服务统一管理</h3><h3 id="实战云原生微服务基础架构"><a href="#实战云原生微服务基础架构" class="headerlink" title="实战云原生微服务基础架构"></a>实战云原生微服务基础架构</h3><p>本篇《<a href="https://gitbook.cn/gitchat/activity/61a44bebc5bdf0562bdc8c06">云原生基础架构实践</a>》Chat 集成云原生基础架构（K8s）特点实现以上功能、特性，加上基础架构的鉴权、授权、分布式互调等多维度进行实战讲解，解决微服务中多重组件复杂化形式，让微服务们飞一会儿。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="学习" scheme="http://xiao8.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Chat" scheme="http://xiao8.github.io/tags/Chat/"/>
    
    <category term="K8s" scheme="http://xiao8.github.io/tags/K8s/"/>
    
    <category term="微服务" scheme="http://xiao8.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>WebClient 增删改查</title>
    <link href="http://xiao8.github.io/2021/11/16/webclient-restful-api/"/>
    <id>http://xiao8.github.io/2021/11/16/webclient-restful-api/</id>
    <published>2021-11-16T07:27:25.000Z</published>
    <updated>2022-07-28T07:07:22.945Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Webclient-使用场景"><a href="#Webclient-使用场景" class="headerlink" title="Webclient 使用场景"></a>Webclient 使用场景</h2><p>前面介绍了 什么是阻塞、非阻塞，以及对应的客户端库，非阻塞在<strong>高并发</strong>、<strong>内存不足</strong>的情况下，还是一个不错的选择，当被访问者的服务响应很慢、或者自己在请求对方时，并不是很想知道对方返回的结果，都可以使用 Webclient 来进行非阻塞式请求。下面紧接着讲非阻塞客户端库 Webclient如何实现增删改查。</p><h2 id="Webclient-的RestFul-请求"><a href="#Webclient-的RestFul-请求" class="headerlink" title="Webclient 的RestFul 请求"></a>Webclient 的RestFul 请求</h2><h3 id="一、RESTful风格与HTTP-method"><a href="#一、RESTful风格与HTTP-method" class="headerlink" title="一、RESTful风格与HTTP method"></a>一、RESTful风格与HTTP method</h3><p>熟悉RESTful风格的朋友，应该了解RESTful风格API使用HTTP method表达对资源的操作。</p><table><thead><tr><th>常用HTTP方法</th><th>RESTful风格语义（操作）</th></tr></thead><tbody><tr><td>POST</td><td>新增、提交数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>PUT</td><td>更新、修改数据</td></tr><tr><td>GET</td><td>查询、获取数据</td></tr></tbody></table><p>下面我们就来讲下这些资源场景的使用方式。</p><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>POST等常见使用如下方法：</p><ul><li>block()阻塞获取响应结果的方法</li><li>subscribe()非阻塞异步结果订阅方法</li><li>retrieve(）获取HTTP响应体，exchange()除了获取HTTP响应体，还可以获取HTTP 状态码、headers、cookies等HTTP报文信息。</li><li>使用Mono接收单个对象的响应结果，使用Flux接收集合类对象的响应结果。</li><li>占位符语法传参方式</li></ul><h4 id="模拟表单提交数据"><a href="#模拟表单提交数据" class="headerlink" title="模拟表单提交数据"></a>模拟表单提交数据</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void testFormSubmit() {</span><br><span class="line"></span><br><span class="line">    MultiValueMap&lt;String, String&gt; map = new LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">    map.add("username", "damoin");</span><br><span class="line">    map.add("UID", "11024319902323");</span><br><span class="line"></span><br><span class="line">    Mono&lt;String&gt; mono = webClientBuilder.build().post()</span><br><span class="line">                    .uri("http://rest-service-service/add")</span><br><span class="line">                    .contentType(MediaType.APPLICATION_FORM_URLENCODED)</span><br><span class="line">                    .body(BodyInserters.fromFormData(map))</span><br><span class="line">                    .retrieve()</span><br><span class="line">                    .bodyToMono(String.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(mono.block());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如上所示，在提交表单的时候，需要说明表单数据类型，以及表单的具体数据，我们知道：常见的表单数据都是以map形式存在，在请求后要想获取响应返回，可以使用<code>retrieve</code>函数，同时可以借助Mono来对返回结果进行类型转换，如果是单个对象使用Mono，如果是集合流，可以使用Flux。同时，如果想要阻塞拿到返回结果的信息，可以通过<code>block</code>函数来处理。</p><h5 id="传输对象以JSON数据形式发送"><a href="#传输对象以JSON数据形式发送" class="headerlink" title="传输对象以JSON数据形式发送"></a>传输对象以JSON数据形式发送</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void testPostJson() {</span><br><span class="line">    SysUser user = new SysUser();</span><br><span class="line">    user.setRealName("dwdwdww");</span><br><span class="line">    user.setPhone("32323232");</span><br><span class="line">    Mono&lt;String&gt; mono = webClientBuilder.build()</span><br><span class="line">                    .post()</span><br><span class="line">                    .uri("http://rest-service-service/add")</span><br><span class="line">                    .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                    .bodyValue(user)</span><br><span class="line">                    .retrieve()</span><br><span class="line">                    .bodyToMono(String.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(mono.block());</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>这里将传输的数据以Json格式来进行发送给对方，同样需要注明数据类型<code>MediaType.APPLICATION_JSON</code>，其它的函数都是跟上面一样。</p><h5 id="模拟向服务端发送JSON字符串数据"><a href="#模拟向服务端发送JSON字符串数据" class="headerlink" title="模拟向服务端发送JSON字符串数据"></a>模拟向服务端发送JSON字符串数据</h5><p>如果有时候对方需要的不是一个JSON对象，可能是需要一个JSON字符串，那怎么办呢？</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void testPostJsonStr() {</span><br><span class="line">    String jsonStr = "{\"realName\": \"damon\",\"phone\": \"32323232\"}";</span><br><span class="line">    Mono&lt;String&gt; mono = webClientBuilder.build().post()</span><br><span class="line">                    .uri("http://rest-service-service/add")</span><br><span class="line">                    .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                    .body(BodyInserters.fromValue(jsonStr))</span><br><span class="line">                    .retrieve()</span><br><span class="line">                    .bodyToMono(String.class);</span><br><span class="line"></span><br><span class="line">    // 输出结果</span><br><span class="line">    System.out.println(mono.block());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此时，数据类型同样还是 <code>MediaType.APPLICATION_JSON</code>，但传输的是JSON串。</p><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><p>使用 DELETE方法去删除资源，删除一个已经存在的资源，使用webClient的delete()方法。该方法会向URL代表的资源发送一个HTTP DELETE方法请求：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void testDelete()  {</span><br><span class="line">  webClientBuilder.build()</span><br><span class="line">  .delete()</span><br><span class="line">  .uri("http://rest-service-service/1");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h4><p>修改一个已经存在的资源，使用webClient的put()方法。该方法会向URL代表的资源发送一个HTTP PUT方法请求：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void testPut() {</span><br><span class="line">        SysUser user = new SysUser();</span><br><span class="line">        user.setRealName("dwdwdww");</span><br><span class="line">        user.setPhone("32323232");</span><br><span class="line"></span><br><span class="line">        Mono&lt;String&gt; mono = webClientBuilder.build()</span><br><span class="line">                        .put()</span><br><span class="line">                        .uri("http://rest-service-service/1")</span><br><span class="line">                        .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                        .bodyValue(user).retrieve().bodyToMono(String.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(mono.block());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里以传json数据的格式来进行发送修改，修改完成后返回修改结果信息。</p><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p>新增完数据后，我们来查看数据对象，如果是一个对象数据的话，可以使用 Mono：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(value = "/getClientResByWebClient2", produces = MediaType.TEXT_EVENT_STREAM_VALUE)</span><br><span class="line">    public Mono&lt;String&gt; getClientResByWebClient2() throws Exception {</span><br><span class="line">             Mono&lt;String&gt; resp = webClientBuilder.build()</span><br><span class="line">             .get()</span><br><span class="line">             .uri("http://diff-ns-service-service/all/getService")</span><br><span class="line">             .retrieve().bodyToMono(String.class);</span><br><span class="line">             //.exchange().flatMap(clientResp -&gt; clientResp.bodyToMono(String.class));</span><br><span class="line"></span><br><span class="line">            resp.subscribe(body -&gt; System.out.println(body));</span><br><span class="line">            return resp;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>如果是多个对象，那就是集合集，此时需要用Flux来获取：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void testFlux() {</span><br><span class="line">    Flux&lt;SysUser&gt; flux = webClientBuilder.build()</span><br><span class="line">              .get()</span><br><span class="line">              .uri("http://diff-ns-service-service/all")</span><br><span class="line">              .retrieve()</span><br><span class="line">              .bodyToFlux(SysUser.class);</span><br><span class="line">      List&lt;SysUser&gt; li = flux.collectList().block();</span><br><span class="line">      assert li != null;</span><br><span class="line">      System.out.println("li集合元素数量：" + li.size());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><br><p><span class="suffix" style="display: none;"></span></p><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码:</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;">https://gitee.com/damon_one/spring-cloud-k8s</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">交个朋友之猿天地</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://xiao8.github.io" style="text-decoration: none" title="">交个朋友之猿天地 | 微服务 | 容器化 | 自动化</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：交个朋友之猿天地"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="后端" scheme="http://xiao8.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://xiao8.github.io/tags/Java/"/>
    
    <category term="响应式编程" scheme="http://xiao8.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>阻塞与非阻塞式客户端</title>
    <link href="http://xiao8.github.io/2021/11/15/non-block-client/"/>
    <id>http://xiao8.github.io/2021/11/15/non-block-client/</id>
    <published>2021-11-15T03:42:07.000Z</published>
    <updated>2022-07-28T07:07:25.599Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>阻塞是指程序会一直等待该进程或线程完成当前任务期间不做其它事情。而非阻塞，是指当前线程在处理一些事情的同时，还可以处理其它的事情，并不需要等待当前事件完成才执行其它事件。</p><h2 id="阻塞与非阻塞客户端"><a href="#阻塞与非阻塞客户端" class="headerlink" title="阻塞与非阻塞客户端"></a>阻塞与非阻塞客户端</h2><p>对于请求当中，我们有需要借助一些请求封装的客户端，这里可以分为两大类：阻塞式、非阻塞式。</p><p>阻塞式客户端以常见的 <code>RestTemplate</code>为例，这是一种常见的客户端请求封装，要创建负载平衡<code>RestTemplate</code>，下面看看其Bean：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@LoadBalanced</span><br><span class="line">@Bean</span><br><span class="line">public RestTemplate restTemplate() {</span><br><span class="line">    return new RestTemplate();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在底层，RestTemplate 使用了基于每个请求对应一个线程模型（thread-per-request）的 Java Servlet API。在阻塞客户端中，这意味着，直到 Web 客户端收到响应之前，线程都将一直被阻塞下去。而阻塞带来的问题是：每个线程都消耗了一定的内存和 CPU 周期。</p><p>如果在并发下，等待结果的请求迟早都会堆积起来。这样，程序将创建很多线程，这些线程将耗尽线程池或占用所有可用内存。由于频繁的 CPU 线程切换，我们还会遇到性能下降的问题。</p><p>这在 Spring5 中，提出了一种新的客户端抽象：反应式客户端 <code>WebClient</code>，而 WebClient 使用了 <code>Spring Reactive Framework</code> 所提供的异步非阻塞解决方案。所以，当 <code>RestTemplate</code>创建一个个新的线程时，Webclient是为其创建类似task的线程，并且在底层，<br>Reactive 框架将对这些 task 进行排队，并且仅在适当的响应可用时再执行它们。WebClient 是 Spring WebFlux 库的一部分。所以，我们还可以使用了流畅的函数式 API 编程，并将响应类型作为声明来进行组合。如果需要使用 WebClient，同样可以创建：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@LoadBalanced</span><br><span class="line">public WebClient.Builder loadBalancedWebClientBuilder() {</span><br><span class="line">    return WebClient.builder();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>假设这里有一个响应非常慢的服务rest-service，我们分别用阻塞式、非阻塞式客户端来测试一下。</p><h4 id="阻塞式"><a href="#阻塞式" class="headerlink" title="阻塞式"></a>阻塞式</h4><p>我们利用 <code>RestTemplate</code>实现阻塞式请求：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@LoadBalanced</span><br><span class="line">public RestTemplate restTemplate() {</span><br><span class="line">return new RestTemplate();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">@GetMapping("/getClientRes")</span><br><span class="line">public Response&lt;Object&gt; getClientRes() throws Exception {</span><br><span class="line">    System.out.println("block api enter");</span><br><span class="line">HttpHeaders headers = new HttpHeaders();</span><br><span class="line">MediaType type = MediaType.parseMediaType("application/json; charset=UTF-8");</span><br><span class="line">headers.setContentType(type);</span><br><span class="line">headers.add("Accept", MediaType.APPLICATION_JSON.toString());</span><br><span class="line">HttpEntity&lt;String&gt; formEntity = new HttpEntity&lt;String&gt;(null, headers);</span><br><span class="line">String body = "";</span><br><span class="line">try {</span><br><span class="line">ResponseEntity&lt;String&gt; responseEntity = restTemplate.exchange("http://diff-ns-service-service/getservicedetail?servicename=cas-server-service",</span><br><span class="line">HttpMethod.GET, formEntity, String.class);</span><br><span class="line">System.out.println(JSON.toJSONString(responseEntity));</span><br><span class="line">if (responseEntity.getStatusCodeValue() == 200) {</span><br><span class="line">    System.out.println("block api exit");</span><br><span class="line">return Response.ok(responseEntity.getBody());</span><br><span class="line">}</span><br><span class="line">} catch (Exception e) {</span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">}</span><br><span class="line">System.out.println("block api failed, exit");</span><br><span class="line">return Response.error("failed");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在启动服务请求后，发现其打印：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">block api enter</span><br><span class="line"></span><br><span class="line">[{"host":"10.244.0.55","instanceId":"71f96128-3bb1-11ec-97e6-ac1f6ba00d36","metadata":{"kubectl.kubernetes.io/last-applied-configuration":"{\"apiVersion\":\"v1\",\"kind\":\"Service\",\"metadata\":{\"annotations\":{},\"name\":\"cas-server-service\",\"namespace\":\"system-server\"},\"spec\":{\"ports\":[{\"name\":\"cas-server01\",\"port\":2000,\"targetPort\":\"cas-server01\"}],\"selector\":{\"app\":\"cas-server\"}}}\n","port.cas-server01":"2000","k8s_namespace":"system-server"},"namespace":"system-server","port":2000,"scheme":"http","secure":false,"serviceId":"cas-server-service","uri":"http://10.244.0.55:2000"},{"host":"10.244.0.56","instanceId":"71fc1c14-3bb1-11ec-97e6-ac1f6ba00d36","metadata":{"$ref":"$[0].metadata"},"namespace":"system-server","port":2000,"scheme":"http","secure":false,"serviceId":"cas-server-service","uri":"http://10.244.0.56:2000"}]</span><br><span class="line"></span><br><span class="line">block api exit</span><br></pre></td></tr></tbody></table></figure><h4 id="非阻塞式"><a href="#非阻塞式" class="headerlink" title="非阻塞式"></a>非阻塞式</h4><p>上面的打印符合我们的逾期，接下来我们来看看非阻塞、反应式客户端请求：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@LoadBalanced</span><br><span class="line">public WebClient.Builder loadBalancedWebClientBuilder() {</span><br><span class="line">    return WebClient.builder();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@GetMapping(value = "/getClientResByWebClient", produces = MediaType.TEXT_EVENT_STREAM_VALUE)</span><br><span class="line">public Mono&lt;String&gt; getClientResByWebClient() throws Exception {</span><br><span class="line">    System.out.println("no block api enter");</span><br><span class="line">Mono&lt;String&gt; resp = webClientBuilder.build().get()</span><br><span class="line">.uri("http://diff-ns-service-service/getservicedetail?servicename=cas-server-service").retrieve()</span><br><span class="line">.bodyToMono(String.class);</span><br><span class="line">resp.subscribe(body -&gt; System.out.println(body.toString()));</span><br><span class="line">System.out.println("no block api exit");</span><br><span class="line">return resp;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>执行完代码后，看打印：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">no block api enter</span><br><span class="line"></span><br><span class="line">no block api exit</span><br><span class="line"></span><br><span class="line">[{"host":"10.244.0.55","instanceId":"71f96128-3bb1-11ec-97e6-ac1f6ba00d36","metadata":{"kubectl.kubernetes.io/last-applied-configuration":"{\"apiVersion\":\"v1\",\"kind\":\"Service\",\"metadata\":{\"annotations\":{},\"name\":\"cas-server-service\",\"namespace\":\"system-server\"},\"spec\":{\"ports\":[{\"name\":\"cas-server01\",\"port\":2000,\"targetPort\":\"cas-server01\"}],\"selector\":{\"app\":\"cas-server\"}}}\n","port.cas-server01":"2000","k8s_namespace":"system-server"},"namespace":"system-server","port":2000,"scheme":"http","secure":false,"serviceId":"cas-server-service","uri":"http://10.244.0.55:2000"},{"host":"10.244.0.56","instanceId":"71fc1c14-3bb1-11ec-97e6-ac1f6ba00d36","metadata":{"$ref":"$[0].metadata"},"namespace":"system-server","port":2000,"scheme":"http","secure":false,"serviceId":"cas-server-service","uri":"http://10.244.0.56:2000"}]</span><br></pre></td></tr></tbody></table></figure><p>在本例中，WebClient 返回一个 Mono 生产者后完成方法的执行。如果一旦结果可用，发布者将开始向其订阅者发送数据。调用这个API的客户端（浏览器）也将订阅返回的 Mono 对象。</p><h4 id="阻塞式转非阻塞式"><a href="#阻塞式转非阻塞式" class="headerlink" title="阻塞式转非阻塞式"></a>阻塞式转非阻塞式</h4><p>可以将前面的阻塞式请求，直接转为非阻塞请求，前提是你使用的是 Spring5，此时，可以直接这样来写，贴代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping("/hello")</span><br><span class="line">public Mono&lt;String&gt; hello() {</span><br><span class="line">    return Mono.fromCallable(() -&gt; restTemplate.getForObject("http://diff-ns-service-service/all/getService", String.class))</span><br><span class="line">            .subscribeOn(Schedulers.elastic());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样后，在请求访问时，直接返回了提供者服务返回的信息体：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{"result":{"status":200,"code":0,"msg":"success"},"data":[{"host":"10.244.0.55","instanceId":"71f96128-3bb1-11ec-97e6-ac1f6ba00d36","metadata":{"kubectl.kubernetes.io/last-applied-configuration":"{\"apiVersion\":\"v1\",\"kind\":\"Service\",\"metadata\":{\"annotations\":{},\"name\":\"cas-server-service\",\"namespace\":\"system-server\"},\"spec\":{\"ports\":[{\"name\":\"cas-server01\",\"port\":2000,\"targetPort\":\"cas-server01\"}],\"selector\":{\"app\":\"cas-server\"}}}\n","port.cas-server01":"2000","k8s_namespace":"system-server"},"namespace":"system-server","port":2000,"scheme":"http","secure":false,"serviceId":"cas-server-service","uri":"http://10.244.0.55:2000"},{"host":"10.244.0.56","instanceId":"71fc1c14-3bb1-11ec-97e6-ac1f6ba00d36","metadata":{"$ref":"$[0].metadata"},"namespace":"system-server","port":2000,"scheme":"http","secure":false,"serviceId":"cas-server-service","uri":"http://10.244.0.56:2000"}]}</span><br></pre></td></tr></tbody></table></figure><p>这里需要注意的是，请求时，需要直接返回服务提供者的标准信息体，不能再作二次封装返回，否则，只能拿到信息:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{"result":{"status":200,"code":0,"msg":"success"},"data":{"scanAvailable":true}}</span><br></pre></td></tr></tbody></table></figure><p>表示本次 callable 为true，但这不是我们需要的信息，我们还是需要其本身返回的业务数据。所以需要提供者的返回标准化，因为直接将信息返回给可接收的浏览器等前端。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在大部分场景下， <code>RestTemplate</code> 还是继续被使用的，但有些场景下，反应式非阻塞请求还是必须的，系统资源要少得多。<code>WebClient</code>不失为是一个更好的选择。</p><br><br><p><span class="suffix" style="display: none;"></span></p><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码:</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;">https://gitee.com/damon_one/spring-cloud-k8s</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">交个朋友之猿天地</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://xiao8.github.io" style="text-decoration: none" title="">交个朋友之猿天地 | 微服务 | 容器化 | 自动化</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：交个朋友之猿天地"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="后端" scheme="http://xiao8.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://xiao8.github.io/tags/Java/"/>
    
    <category term="响应式编程" scheme="http://xiao8.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>注意了，ribbon将被替换</title>
    <link href="http://xiao8.github.io/2021/11/15/spring-cloud-loadbalancer/"/>
    <id>http://xiao8.github.io/2021/11/15/spring-cloud-loadbalancer/</id>
    <published>2021-11-15T03:39:19.000Z</published>
    <updated>2022-07-28T07:07:23.731Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="Ribbon"><a href="#Ribbon" class="headerlink" title="- Ribbon"></a>- Ribbon</h3><p>Ribbon 是由 Netflix 发布的负载均衡器，它有助于控制 HTTP 和 TCP 的客户端的行为。Ribbon 属于客户端负载均衡。大家都知道，在我们最早使用 Springcloud 微服务架构时，就是使用 Netflix 公司的荣誉出品：<code>https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/</code>。但可惜的是，Eureka 早就正式被官方废弃，不再更新了。这也许是为了更好的统一架构。</p><h3 id="Spring-cloud-loadbalancer"><a href="#Spring-cloud-loadbalancer" class="headerlink" title="- Spring-cloud-loadbalancer"></a>- Spring-cloud-loadbalancer</h3><p>Spring-cloud-loadbalancer，是官方正式推出的一款新负载均衡利器。早在 2017 年 spring 开始尝试开发<code>spring-cloud-loadbalancer</code> 替代 ribbon，项目托管在 <a href="https://github.com/spring-cloud-incubator/spring-cloud-loadbalancer">spring-cloud-incubator 孵化器</a>，而后，经过一段时间，突然把此项目标记成归档迁移到<a href="https://github.com/spring-cloud/spring-cloud-commons">spring-cloud-commons</a>，说明官方在做统一公共基础架构的决心在一步步前进。</p><p>早在 <a href="https://spring.io/blog/2019/08/19/spring-cloud-hoxton-m2-released">Spring Cloud Hoxton.M2</a>，第一个整合<code>spring-cloud-loadbalancer</code>来替换老的 ribbon:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Spring Cloud Hoxton.M2 is the first release containing both blocking and non-blocking load balancer client implementations as an alternative to Netflix Ribbon which has entered maintenance mode.</span><br><span class="line"></span><br><span class="line">To use the new&nbsp;`BlockingLoadBalancerClient`&nbsp;with a&nbsp;`RestTemplate`&nbsp;you will need to include&nbsp;`org.springframework.cloud:spring-cloud-loadbalancer`&nbsp;on your application’s classpath. The same dependency can be used in a reactive application when using&nbsp;`@LoadBalanced WebClient.Builder`&nbsp;- the only difference is that Spring Cloud will auto-configure a&nbsp;`ReactorLoadBalancerExchangeFilterFunction`&nbsp;instance. See the&nbsp;[documentation](https://cloud.spring.io/spring-cloud-static/spring-cloud-commons/2.2.0.M2/reference/html/#_spring_resttemplate_as_a_load_balancer_client)&nbsp;for additional information. The new&nbsp;`ReactorLoadBalancerExchangeFilterFunction`&nbsp;can also be autowired and passed directly to&nbsp;`WebClient.Builder`&nbsp;(see the&nbsp;[documentation](https://cloud.spring.io/spring-cloud-commons/reference/html/#webflux-with-reactive-loadbalancer)). For all these features,&nbsp;[Project Reactor](https://projectreactor.io/)-based&nbsp;`RoundRobinLoadBalancer`&nbsp;is used underneath.</span><br></pre></td></tr></tbody></table></figure><p>从这段原文可以看到，目前只支持<code>BlockingLoadBalancerClient</code>，同样是基于 <code>RestTemplate</code>。我们知道 ribbon 也是基于<code>RestTemplate</code>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@LoadBalanced</span><br><span class="line">@Bean</span><br><span class="line">public RestTemplate restTemplate() {</span><br><span class="line">        SimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();</span><br><span class="line">        requestFactory.setReadTimeout(env.getProperty("client.http.request.readTimeout", Integer.class, 15000));</span><br><span class="line">        requestFactory.setConnectTimeout(env.getProperty("client.http.request.connectTimeout", Integer.class, 3000));</span><br><span class="line">        RestTemplate rt = new RestTemplate(requestFactory);</span><br><span class="line">        return rt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但对于配置，ribbon 显然还是较老练：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">backend:</span><br><span class="line">  ribbon:</span><br><span class="line">    client:</span><br><span class="line">      enabled: true</span><br><span class="line">    ServerListRefreshInterval: 5000</span><br><span class="line"></span><br><span class="line">ribbon:</span><br><span class="line">  ConnectTimeout: 3000</span><br><span class="line">  ReadTimeout: 1000</span><br><span class="line">  eager-load:</span><br><span class="line">    enabled: true</span><br><span class="line">    clients: cas-server,customer-server</span><br><span class="line">  MaxAutoRetries: 2</span><br><span class="line">  MaxAutoRetriesNextServer: 3</span><br><span class="line">  OkToRetryOnAllOperations: true</span><br><span class="line">  NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule</span><br></pre></td></tr></tbody></table></figure><p>可以多维度配置：超时、刷新服务列表、重试机制等。</p><p>但对于<code>spring-cloud-loadbalancer</code>，可以没有那么好，毕竟是刚养大的崽。但 Spring Cloud Hoxton 版本中第一次引入同时支持阻塞式与非阻塞式的负载均衡器<code>spring-cloud-loadbalancer</code>来作为已经进入维护状态的 Netflix Ribbon。接下来，我们实战看看如何使用。</p><h2 id="实战spring-cloud-loadbalancer"><a href="#实战spring-cloud-loadbalancer" class="headerlink" title="实战spring-cloud-loadbalancer"></a>实战<code>spring-cloud-loadbalancer</code></h2><p>在使用时，我们从原文中了解到，只需要引入<code>org.springframework.cloud:spring-cloud-loadbalancer</code>依赖，就可以将新的<code>BlockingLoadBalancerClient</code>与<code>RestTemplate</code>一起使用了。同时，该依赖的引入也将支持 Reactive 应用，跟其他使用一样，只需要使用<code>@LoadBalanced</code>来修饰<code>WebClient.Builder</code>即可。</p><p>我们先来引入依赖，这里用的是基于 Nacos 的服务注册与发现，我们先来注入依赖：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-loadbalancer&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure><p>在这里，我们使用到新的负载均衡器，需要排除 ribbon 依赖，不然 loadbalancer 无效。同时，我们需要禁用 ribbon 的负载均衡能力：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    loadbalancer:</span><br><span class="line">      ribbon:</span><br><span class="line">        enabled: false</span><br></pre></td></tr></tbody></table></figure><p>禁用之后，我们在结合<code>RestTemplate</code>使用，并使用<code>@LoadBalanced</code>来修饰<code>WebClient.Builder</code>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@LoadBalanced//就不能用ip等形式来请求其他服务</span><br><span class="line">@Bean</span><br><span class="line">public RestTemplate restTemplate() {</span><br><span class="line">        SimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();</span><br><span class="line">        requestFactory.setReadTimeout(env.getProperty("client.http.request.readTimeout", Integer.class, 15000));</span><br><span class="line">        requestFactory.setConnectTimeout(env.getProperty("client.http.request.connectTimeout", Integer.class, 3000));</span><br><span class="line">        RestTemplate rt = new RestTemplate(requestFactory);</span><br><span class="line">        return rt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个细心的同学可以开始看到：这个和 Ribbon 的配置是一样样的。此时，我们启动服务提供者、消费者即可测试。这里就不再展示了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>按照官方的孵化，新的负载均衡器将会取代老的 ribbon，毕竟引入了新的功能：<strong>Reactive</strong>，加入了对其的大力支持。这在性能方面有所提升。</p><p>同时，现在<code>spring-cloud-loadbalancer</code>还是存在一定局限的，比如：</p><ul><li>ribbon 提供几种默认的负载均衡策略</li><li>目前<code>spring-cloud-loadbalancer</code> 仅支持重试操作的配置</li><li>ribbon 支持超时、懒加载处理、重试及其和 hystrix 整合高级属性等</li></ul><p>在 Spring-cloud 体系中，大部分范围还是老实使用 Ribbon，但基于 spring-cloud-k8s，可能需要使用基于<code>spring-cloud-starter-kubernetes-loadbalancer</code>。因为在前面实践过，基于 Ribbon 的 LB，无法跨命名空间来实现服务间的相互访问。</p><br><br><p><span class="suffix" style="display: none;"></span></p><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码:</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;">https://gitee.com/damon_one/spring-cloud-k8s</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">交个朋友之猿天地</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://xiao8.github.io" style="text-decoration: none" title="">交个朋友之猿天地 | 微服务 | 容器化 | 自动化</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：交个朋友之猿天地"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="后端" scheme="http://xiao8.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://xiao8.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>k8s 集群从0到1</title>
    <link href="http://xiao8.github.io/2021/11/12/kubeadm-install-k8s/"/>
    <id>http://xiao8.github.io/2021/11/12/kubeadm-install-k8s/</id>
    <published>2021-11-12T02:08:01.000Z</published>
    <updated>2022-07-28T07:07:25.634Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&amp;emsp;&amp;emsp; 本文只讲 docker + kubernetes 集群的 kubeadm 部署方式，不讲 k8s 各组件工作原理。个人认为在学习 k8s 的过程中，先动手搭建起来一个测试集群，比一味的看书学原理要好得多，一边操作一边学习是比较有效率的。</p><p>&amp;emsp;&amp;emsp;使用 yum 安装 docker、 kubelet、 kubeadm 包的方式，会自动部署 service 文件及环境，相比二进制安装更简单一些。<a href="https://note.youdao.com/">二进制安装</a>更复杂但是也更灵活一些，学习二进制安装有助于用户学习各部件工作原理，以及排错能力。下面先介绍比较简单的 yum 安装的方式。</p><h1 id="Yum-安装包部署k8s-集群流程"><a href="#Yum-安装包部署k8s-集群流程" class="headerlink" title="Yum 安装包部署k8s 集群流程"></a>Yum 安装包部署k8s 集群流程</h1><h2 id="一、准备工作-（所有节点）"><a href="#一、准备工作-（所有节点）" class="headerlink" title="一、准备工作 （所有节点）"></a>一、准备工作 （所有节点）</h2><ol><li><p>配置所有节点互通 ssh 免密（ssh-copy-id）</p></li><li><p>配置所有节点 /etc/hosts 文件统一记录所有机器 hostname 和ip。hosts 文件需要在新增节点时更新，在大型集群中最好通过 git 来同步所有机器。</p> <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-1 data]# cat /etc/hosts</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">192.168.63.131 k8s-master-1</span><br><span class="line">192.168.63.141 k8s-node-1</span><br><span class="line">192.168.63.142 k8s-node-2</span><br><span class="line">192.168.63.143 k8s-node-3</span><br></pre></td></tr></tbody></table></figure></li><li><p>ntp 时间同步，k8s 很多组件工作需要保证所有节点 时间一致。</p> <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum install -y ntpdate</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用公网 ntp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ntpdate us.pool.ntp.org</span></span><br><span class="line"></span><br><span class="line">时间不对的话确认系统时区</span><br><span class="line"><span class="meta">#</span><span class="bash"> ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>关闭 防火墙，selinux ，swap</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">测试环境</span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl stop firewalld</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl <span class="built_in">disable</span> firewalld</span></span><br><span class="line">正式环境（不允许关闭防火墙，保证默认规则为 ACCEPT ）</span><br><span class="line"><span class="meta">#</span><span class="bash"> iptables -L | grep Chain</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # setenforce 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/selinux/config</span></span><br><span class="line">SELINUX=disabled</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> swapoff -a</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 编辑/etc/fstab，注释掉包含swap的那一行即可，重启后可永久关闭</span></span></span><br></pre></td></tr></tbody></table></figure></li><li><p>修改必要的内核参数</p> <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">二层的网桥在转发包时也会被iptables的FORWARD规则所过滤</span><br><span class="line">linux主机有多个网卡时一个网卡收到的信息是否能够传递给其他的网卡</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> modprobe br_netfilter</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/sysctl.d/k8s.conf</span></span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> sysctl -p /etc/sysctl.d/k8s.conf</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>配置 yum 源装包。</p><ul><li>使用 docker-ce 官方 yum 源安装  docker-ce 软件包</li></ul> <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一种：官方提供的脚本</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二种：手动添加源安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum remove docker \</span></span><br><span class="line"><span class="bash">                 docker-client \</span></span><br><span class="line"><span class="bash">                 docker-client-latest \</span></span><br><span class="line"><span class="bash">                 docker-common \</span></span><br><span class="line"><span class="bash">                 docker-latest \</span></span><br><span class="line"><span class="bash">                 docker-latest-logrotate \</span></span><br><span class="line"><span class="bash">                docker-logrotate \</span></span><br><span class="line"><span class="bash">            docker-engine</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install -y yum-utils \</span></span><br><span class="line"><span class="bash"> device-mapper-persistent-data \</span></span><br><span class="line"><span class="bash"> lvm2</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum-config-manager \</span></span><br><span class="line"><span class="bash">  --add-repo \</span></span><br><span class="line"><span class="bash">  http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install docker-ce docker-ce-cli containerd.io</span></span><br><span class="line">指定版本</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install docker-ce-18.09.1 docker-ce-cli-18.09.1 containerd.io</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>使用 阿里云的 yum 源安装  kubelet kubeadm kubectl 软件包</li></ul> <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-1 data]# cat /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">        http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line"></span><br><span class="line">[root@k8s-master-1 data]# yum install -y kubelet-1.15.6 kubeadm-1.15.6 kubectl-1.15.6</span><br></pre></td></tr></tbody></table></figure></li><li><p>开启docker 服务</p> <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl start docker ; systemctl <span class="built_in">enable</span> docker</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker run hello-world      测试docker 是否可用</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>开启kubelet 服务</p> <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl <span class="built_in">enable</span> kubelet ; systemctl start kubelet</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发现kubelet 启动报错，这是正常的，因为缺少证书，kubeadm 部署后，即可正常启动。</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>确保 kubelet 和 docker 的 cgroup drive 一致，使用 systemd 作为initd 的发行版本，推荐使用systemd ，cgroup 管理更加稳定</p> <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker info | grep -i cgroup</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/systemd/system/kubelet.service.d/10-kubeadm.conf</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 修改 docker</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/docker/daemon.json</span></span><br><span class="line">{</span><br><span class="line"> "exec-opts":["native.cgroupdriver=systemd"]</span><br><span class="line">}</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 修改 kubelet</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sed -i <span class="string">"s/cgroup-driver=systemd/cgroup-driver=cgroupfs/g"</span> /etc/systemd/system/kubelet.service.d/10-kubeadm.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl daemon-reload</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>提前准备镜像，kubeadm 工具部署集群时需要用到一些镜像，默认去墙外的网站拉取，如果你的机器不能访问墙外的世界，那就需要提前准备，并且把准备的镜像打上默认需要的版本的 tag， 学习的路上总是有一些障碍的，还好阿里的源为我们准备了这些镜像</p><ul><li>查看kubeadm 需要的所有镜像</li></ul> <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-1 data]# kubeadm config images list --kubernetes-version=v1.16.2</span><br><span class="line">k8s.gcr.io/kube-apiserver:v1.16.2</span><br><span class="line">k8s.gcr.io/kube-controller-manager:v1.16.2</span><br><span class="line">k8s.gcr.io/kube-scheduler:v1.16.2</span><br><span class="line">k8s.gcr.io/kube-proxy:v1.16.2</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd:3.3.15-0</span><br><span class="line">k8s.gcr.io/coredns:1.6.2</span><br></pre></td></tr></tbody></table></figure><ul><li>上面 k8s.gcr.io 的地址在墙外，我们换成阿里云地址就可以拉下来。registry.cn-hangzhou.aliyuncs.com/google_containers/kube-xxx:v1.16.2</li></ul> <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubeadm config images list |sed -e 's/^/docker pull /g' -e 's#k8s.gcr.io#docker.io/registry.cn-hangzhou.aliyuncs.com/google_containers#g' |sh -x</span><br><span class="line">docker images |grep registry.cn-hangzhou.aliyuncs.com/google_containers |awk '{print "docker tag ",$1":"$2,$1":"$2}' |sed -e 's#docker.io/mirrorgooglecontainers#k8s.gcr.io#2' |sh -x</span><br><span class="line">docker images |grep registry.cn-hangzhou.aliyuncs.com/google_containers |awk '{print "docker rmi ", $1":"$2}' |sh -x</span><br><span class="line">docker pull coredns/coredns:1.2.2</span><br><span class="line">docker tag coredns/coredns:1.2.2 k8s.gcr.io/coredns:1.2.2</span><br><span class="line">docker rmi coredns/coredns:1.2.2</span><br></pre></td></tr></tbody></table></figure><ul><li><p>如果我们的 k8s 版本在 1.13 以上 可以直接用 –image-repository 修改 kubeadm 拉取镜像的地址。</p><blockquote><p>kubeadm init –image-repository registry.aliyuncs.com/google_containers</p></blockquote></li></ul></li></ol><h2 id="二、部署-master-节点（master节点）"><a href="#二、部署-master-节点（master节点）" class="headerlink" title="二、部署 master 节点（master节点）"></a>二、部署 master 节点（master节点）</h2><ol><li><p>使用 kubeadm 初始化 k8s 集群 master 节点，可以看到 kubeadm 都做了那些工作。</p> <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-1 ~]# kubeadm init --kubernetes-version=v1.16.2 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.96.0.0/12；</span><br><span class="line">[init] Using Kubernetes version: v1.16.2</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">[WARNING SystemVerification]: this Docker version is not on the list of validated versions: 19.03.4. Latest validated version: 18.09</span><br><span class="line">[WARNING Hostname]: hostname "k8s-master-1" could not be reached</span><br><span class="line">[WARNING Hostname]: hostname "k8s-master-1": lookup k8s-master-1 on 192.168.63.2:53: server misbehaving</span><br><span class="line">[WARNING Service-Kubelet]: kubelet service is not enabled, please run 'systemctl enable kubelet.service'</span><br><span class="line">[preflight] Pulling images required for setting up a Kubernetes cluster</span><br><span class="line">[preflight] This might take a minute or two, depending on the speed of your internet connection</span><br><span class="line">[preflight] You can also perform this action in beforehand using 'kubeadm config images pull'</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"</span><br><span class="line">[kubelet-start] Activating the kubelet service</span><br><span class="line">[certs] Using certificateDir folder "/etc/kubernetes/pki"</span><br><span class="line">[certs] Generating "ca" certificate and key</span><br><span class="line">[certs] Generating "apiserver" certificate and key</span><br><span class="line">[certs] apiserver serving cert is signed for DNS names [k8s-master-1 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 192.168.63.131]</span><br><span class="line">[certs] Generating "apiserver-kubelet-client" certificate and key</span><br><span class="line">[certs] Generating "front-proxy-ca" certificate and key</span><br><span class="line">[certs] Generating "front-proxy-client" certificate and key</span><br><span class="line">[certs] Generating "etcd/ca" certificate and key</span><br><span class="line">[certs] Generating "etcd/server" certificate and key</span><br><span class="line">[certs] etcd/server serving cert is signed for DNS names [k8s-master-1 localhost] and IPs [192.168.63.131 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating "etcd/peer" certificate and key</span><br><span class="line">[certs] etcd/peer serving cert is signed for DNS names [k8s-master-1 localhost] and IPs [192.168.63.131 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating "etcd/healthcheck-client" certificate and key</span><br><span class="line">[certs] Generating "apiserver-etcd-client" certificate and key</span><br><span class="line">[certs] Generating "sa" key and public key</span><br><span class="line">[kubeconfig] Using kubeconfig folder "/etc/kubernetes"</span><br><span class="line">[kubeconfig] Writing "admin.conf" kubeconfig file</span><br><span class="line">[kubeconfig] Writing "kubelet.conf" kubeconfig file</span><br><span class="line">[kubeconfig] Writing "controller-manager.conf" kubeconfig file</span><br><span class="line">[kubeconfig] Writing "scheduler.conf" kubeconfig file</span><br><span class="line">[control-plane] Using manifest folder "/etc/kubernetes/manifests"</span><br><span class="line">[control-plane] Creating static Pod manifest for "kube-apiserver"</span><br><span class="line">[control-plane] Creating static Pod manifest for "kube-controller-manager"</span><br><span class="line">[control-plane] Creating static Pod manifest for "kube-scheduler"</span><br><span class="line">[etcd] Creating static Pod manifest for local etcd in "/etc/kubernetes/manifests"</span><br><span class="line">[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory "/etc/kubernetes/manifests". This can take up to 4m0s</span><br><span class="line">[apiclient] All control plane components are healthy after 22.511803 seconds</span><br><span class="line">[upload-config] Storing the configuration used in ConfigMap "kubeadm-config" in the "kube-system" Namespace</span><br><span class="line">[kubelet] Creating a ConfigMap "kubelet-config-1.16" in namespace kube-system with the configuration for the kubelets in the cluster</span><br><span class="line">[upload-certs] Skipping phase. Please see --upload-certs</span><br><span class="line">[mark-control-plane] Marking the node k8s-master-1 as control-plane by adding the label "node-role.kubernetes.io/master=''"</span><br><span class="line">[mark-control-plane] Marking the node k8s-master-1 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]</span><br><span class="line">[bootstrap-token] Using token: tacwl8.r9rybowvi486j94t</span><br><span class="line">[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster</span><br><span class="line">[bootstrap-token] Creating the "cluster-info" ConfigMap in the "kube-public" namespace</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 192.168.63.131:6443 --token tacwl8.r9rybowvi486j94t \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:83d9e155464739407fe5a782b41eac35c42fcba2a1e8c252066cd7e00eaf21ff</span><br></pre></td></tr></tbody></table></figure></li><li><p>初始化后根据 提示 完成 config 文件的配置，并且记住 kubeadm join 命令，以便于后续添加node 节点。</p> <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mkdir -p <span class="variable">$HOME</span>/.kube</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>部署网络插件,使用  flannel 或者 calico 需要自己选择。calico 需要配置rbac ，新版本已经集成到 calico.yaml文件中。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span></span><br><span class="line">或</span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl apply -f https://docs.projectcalico.org/v3.9/manifests/calico-etcd.yaml</span></span><br><span class="line"></span><br><span class="line">如果没有关闭防火墙需要为calico 打开端口</span><br><span class="line"><span class="meta">#</span><span class="bash"> firewall-cmd --permanent --add-port=5543/tcp --zone=public</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> firewall-cmd --permanent --add-port=179/tcp --zone=public</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> firewall-cmd --reload</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>部署 dashboard   web ui 管理界面。</p><ul><li><p>事先准备镜像</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker pull registry.cn-hangzhou.aliyuncs.com/rsqlh/kubernetes-dashboard:v1.10.1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker tag registry.cn-hangzhou.aliyuncs.com/rsqlh/kubernetes-dashboard:v1.10.1 k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker rmi registry.cn-hangzhou.aliyuncs.com/rsqlh/kubernetes-dashboard:v1.10.1</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>应用 yaml 文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-1 data]# kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml</span><br><span class="line">secret/kubernetes-dashboard-certs created</span><br><span class="line">serviceaccount/kubernetes-dashboard created</span><br><span class="line">role.rbac.authorization.k8s.io/kubernetes-dashboard-minimal created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/kubernetes-dashboard-minimal created</span><br><span class="line">deployment.apps/kubernetes-dashboard created</span><br><span class="line">service/kubernetes-dashboard created</span><br><span class="line"></span><br><span class="line">查看pod</span><br><span class="line"># kubectl get pods -n kube-system</span><br><span class="line">kubernetes-dashboard-57df4db6b-p9sm8      1/1     Running   0          15s</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>开启集群外部访问</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master-1 data]# kubectl get svc -n kube-system</span><br><span class="line">NAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">kube-dns               ClusterIP   10.96.0.10       &lt;none&gt;        53/UDP,53/TCP,9153/TCP   8d</span><br><span class="line">kubernetes-dashboard   ClusterIP   10.110.144.227   &lt;none&gt;        443/TCP                  40s</span><br><span class="line">[root@k8s-master-1 data]# kubectl patch svc kubernetes-dashboard -p '{"spec":{"type":"NodePort"}}' -n kube-system</span><br><span class="line">service/kubernetes-dashboard patched</span><br><span class="line">[root@k8s-master-1 data]# kubectl get svc -n kube-system</span><br><span class="line">NAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">kube-dns               ClusterIP   10.96.0.10       &lt;none&gt;        53/UDP,53/TCP,9153/TCP   8d</span><br><span class="line">kubernetes-dashboard   NodePort    10.110.144.227   &lt;none&gt;        443:30541/TCP            51s</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>通过 ip 和端口 访问会看到需要 token 验证或者 kubeconfig 文件验证。具体的token 获取方法需要创建  serivceaccount 然后 拿到secret 的token 即可，这里不详细阐述。</p></li></ul></li></ol><h2 id="三、部署-node-节点加入集群（node节点）"><a href="#三、部署-node-节点加入集群（node节点）" class="headerlink" title="三、部署 node 节点加入集群（node节点）"></a>三、部署 node 节点加入集群（node节点）</h2><ol><li><p>使用上面记住的命令 初始化 node 节点。</p> <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubeadm join 192.168.63.131:6443 --token tacwl8.r9rybowvi486j94t --discovery-token-ca-cert-hash sha256:83d9e155464739407fe5a782b41eac35c42fcba2a1e8c252066cd7e00eaf21ff</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 如果没有关闭防火墙</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> firewall-cmd --permanent --add-port=6443/tcp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> firewall-cmd --reload</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>如果在node 节点需要使用kubectl 命令 ，需要为对应用户配置 config 文件。</p> <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mkdir -p <span class="variable">$HOME</span>/.kube</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> scp -i master:/etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>kubectl get pod –all-namespaces 检查 pod 运行情况</p></li></ol><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/">https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/</a></p><p><a href="https://github.com/kubernetes/dashboard">https://github.com/kubernetes/dashboard</a></p><br><br><p><span class="suffix" style="display: none;"></span></p><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码:</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;">https://gitee.com/damon_one/spring-cloud-k8s</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">交个朋友之猿天地</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://xiao8.github.io" style="text-decoration: none" title="">交个朋友之猿天地 | 微服务 | 容器化 | 自动化</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：交个朋友之猿天地"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="后端" scheme="http://xiao8.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="K8s" scheme="http://xiao8.github.io/tags/K8s/"/>
    
  </entry>
  
  <entry>
    <title>记录那些年 Nacos 的坑</title>
    <link href="http://xiao8.github.io/2021/11/12/alibaba-nacos/"/>
    <id>http://xiao8.github.io/2021/11/12/alibaba-nacos/</id>
    <published>2021-11-12T01:22:46.000Z</published>
    <updated>2022-07-28T07:07:26.399Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Nacos-旧史"><a href="#Nacos-旧史" class="headerlink" title="Nacos 旧史"></a>Nacos 旧史</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018年11月左右，Springcloud 联合创始人Spencer Gibb在Spring官网的博客页面宣布：阿里巴巴开源 Spring Cloud Alibaba，并发布了首个预览版本。随后，Spring Cloud 官方Twitter也发布了此消息。</span><br></pre></td></tr></tbody></table></figure><p>随着这一消息发布，外面才知道 Nacos 的诞生。毕竟是大厂的 KPI 产物，我们来尝尝鲜。</p><h3 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h3><ul><li><p>Spring Boot: 2.3.12</p></li><li><p>Spring Cloud: Hoxton.SR12</p></li><li><p>Spring Cloud&nbsp;Alibaba:&nbsp;2.2.6.RELEASE</p></li><li><p>Maven:&nbsp;3.5.4</p></li><li><p>Java&nbsp;1.8&nbsp;+</p></li><li><p>Oauth2&nbsp;(Spring Security 5.3.9)</p></li></ul><h3 id="安装-Nacos"><a href="#安装-Nacos" class="headerlink" title="安装 Nacos"></a>安装 Nacos</h3><p>下载 Nacos 地址：<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p><p>版本：v1.2.1</p><p>执行：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Linux/Unix/Mac：sh startup.sh -m standalone</span><br><span class="line"></span><br><span class="line">Windows：cmd startup.cmd -m standalone</span><br></pre></td></tr></tbody></table></figure><p>启动完成之后，访问：<a href="http://127.0.0.1:8848/nacos/%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%BF%9B%E5%85%A5Nacos%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%85%B7%E4%BD%93%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1:8848/nacos/，可以进入Nacos的服务管理页面，具体如下：</a></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93f92dff43ba4fd3a70221218351c619~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>在上面，我们可以看到启动的服务列表信息，同时，我们也可以去配置此服务的相关配置：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/539b4386019d43039abdc819f2f290d9~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>具体的配置如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f96658492f3a4aa492c1800812b1533b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>这里，我们可以设置配置的类型，比如：yaml、properties。默认的是后者，这里我们可以设置：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cas-server</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">a48cec97-fa0f-48e0-97c7-0aced5c7ecbe</span> <span class="comment">#默认public</span></span><br><span class="line">        <span class="comment">#group: mine #${nacos.runtime-env}</span></span><br><span class="line">        <span class="attr">heart-beat-interval:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">heart-beat-timeout:</span> <span class="number">15</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment">#namespace: ${nacos.namespace}</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#默认properties</span></span><br><span class="line">        <span class="comment">#group: ${spring.application.name}</span></span><br><span class="line">        <span class="attr">shared-configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">data-id:</span> <span class="string">application-mysql.properties</span></span><br><span class="line">            <span class="attr">refresh:</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><h3 id="不同-namespace-下的服务互调"><a href="#不同-namespace-下的服务互调" class="headerlink" title="不同 namespace 下的服务互调"></a>不同 namespace 下的服务互调</h3><p>在 Nacos 里，有几个概念，命令空间 namespace、分组 group 等。虽然这里的关键词跟 K8s 类似，但差别还是很大。这就是我今天想说的坑。这里我们默认配置了 properties。</p><p>在 Nacos 中，为了将不同的服务进行划分区域，这也引入了一些概念：namespace、group 我们先来设置一下 namespace，假如我们这里新建一个 namespace：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba183445d0be48e984fea2fac3faa1c2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>那么在注册服务时，我们把这个服务放在了这个 <code>new-NS</code>下，启动该服务，我们来看信息：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4b723c5d5b34f22bec5f6c341958a87~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>我们可以看到<code>cas-server</code>服务在 namespace 名称为 new-NS 下。</p><p>下面，我们继续加入一个新服务，把这个新服务放在默认的 namespace 下，假设利用它来调用 cas-server 服务。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/782676157b4541a58a4e0f56c3cb4926~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>接下来，我们通过命令调用服务:</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -H <span class="string">"Accept: application/json"</span> -H <span class="string">"Authorization:bearer fbbb08b5-fc9c-4bf9-a676-6a1d5d6a0dda"</span> -X GET http://localhost:2001/api/user/get</span><br></pre></td></tr></tbody></table></figure><p>此时可以看到日志：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0b64ebb0c254328b57a40e5cdb3436b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>这里由于被访问的服务是需要鉴权的，所以可以看到：这里的日志是去请求统一认证鉴权中心的<code>check_token</code>接口。由于这两个服务都被注册到 Nacos，这里直接通过域名来请求了。</p><p>但从日志中可以看到，抛出异常：<code>java.lang.IllegalStateException: No instances available for cas-server</code>，这是因为无法解析到这个域名对应的 ip。但从上面，我们可以看到明明有注册信息，为啥不能访问呢？</p><p>这就是 Nacos 现在呈现的第一个坑：<code>无法在跨namespace 下访问其他服务</code>。如果我们把<code>cas-server</code>也放在默认的 namespace 下呢？</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31dfca23ce094b939851254afbb56155~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>再次，我们通过命令调用服务，会发现可以正常请求了：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3aef7e77d97c4c4db6fc213dccb6b358~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>我们发现正常请求后，返回了信息，只不过返回的是<code>400</code>，这是由于我这个 token 失效了，<code>无效的token，请重新认证访问</code>。</p><h3 id="同-namespace-下不同组的服务互调"><a href="#同-namespace-下不同组的服务互调" class="headerlink" title="同 namespace 下不同组的服务互调"></a>同 namespace 下不同组的服务互调</h3><p>上面说到不同 namespace 下的服务互调的问题，接下来，我们看看同一 namespace 下不同分组的服务互调是咋样的呢？</p><p>同样的，我们假设把 cas-server 分配到一个新的 group：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cas-server</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">mine</span></span><br><span class="line">        <span class="attr">heart-beat-interval:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">heart-beat-timeout:</span> <span class="number">15</span></span><br></pre></td></tr></tbody></table></figure><p>新服务<code>rest-service</code>还是放在默认分组<code>DEFAULT_GROUP</code>里：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c562f94cb61a4c40940d2801b17e0820~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>接下来，我们通过命令调用服务:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -H "Accept: application/json" -H "Authorization:bearer fbbb08b5-fc9c-4bf9-a676-6a1d5d6a0dda" -X GET http://localhost:2001/api/user/get</span><br></pre></td></tr></tbody></table></figure><p>我们来看看日志：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bba2aab02ce4a5a8b3be2ae172664f2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>发现还是跟前面说的那种情况请求后一样，仍然抛出异常：<code>java.lang.IllegalStateException: No instances available for cas-server</code>。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在 Nacos 较高版本中验证这两种情况，同样得出相同的结论：<code>同一namespace下的不同group的服务无法相互调用，不同namespace下的同group的服务无法相互调用</code>。</p><h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>在这里说出 Nacos 的坑，并不是在指责 Nacos 团队哈，只是希望官方尽快出新的 feature。</p><br><br><p><span class="suffix" style="display: none;"></span></p><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码:</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;">https://gitee.com/damon_one/spring-cloud-k8s</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">交个朋友之猿天地</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://xiao8.github.io" style="text-decoration: none" title="">交个朋友之猿天地 | 微服务 | 容器化 | 自动化</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：交个朋友之猿天地"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="后端" scheme="http://xiao8.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://xiao8.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>统一认证中心 Oauth2 高可用坑</title>
    <link href="http://xiao8.github.io/2021/11/12/oauth2-ha/"/>
    <id>http://xiao8.github.io/2021/11/12/oauth2-ha/</id>
    <published>2021-11-12T00:10:32.000Z</published>
    <updated>2022-07-28T07:07:24.176Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前面 (<a href="https://xiao8.github.io/2021/11/11/oauth2/">统一认证中心 Oauth2 认证坑</a>) 我们利用<code>user-info-uri</code>来实现消费端的认证信息以及授权获取判断，接下来我们借助 <code>token-info-uri</code> 来实现认证以及授权破。具体配置见：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cas-server-url: http://cas-server</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  path:</span><br><span class="line">    ignores: /,/index,/static/**,/css/**, /image/**, /favicon.ico, /js/**,/plugin/**,/avue.min.js,/img/**,/fonts/**</span><br><span class="line">  oauth2:</span><br><span class="line">    client:</span><br><span class="line">      client-id: rest-service</span><br><span class="line">      client-secret: rest-service-123</span><br><span class="line">      user-authorization-uri: ${cas-server-url}/oauth/authorize</span><br><span class="line">      access-token-uri: ${cas-server-url}/oauth/token</span><br><span class="line">    resource:</span><br><span class="line">      loadBalanced: true</span><br><span class="line">      id: rest-service</span><br><span class="line">      prefer-token-info: true</span><br><span class="line">      token-info-uri: ${cas-server-url}/oauth/check_token</span><br><span class="line">    authorization:</span><br><span class="line">      check-token-access: ${cas-server-url}/oauth/check_token</span><br></pre></td></tr></tbody></table></figure><p>这里的<code>/oauth/check_token</code>是 Oauth2 原生自带的，这里不需要封装。接下来，我们启动服务，在拿到 token 后，通过 token 请求消费端：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2021-11-03 16:40:09.057 DEBUG 24652 --- [io2-2001-exec-4] o.s.web.client.RestTemplate              : HTTP POST http://cas-server/oauth/check_token</span><br><span class="line">2021-11-03 16:40:09.060 DEBUG 24652 --- [io2-2001-exec-4] o.s.web.client.RestTemplate              : Accept=[application/json, application/*+json]</span><br><span class="line">2021-11-03 16:40:09.062 DEBUG 24652 --- [io2-2001-exec-4] o.s.web.client.RestTemplate              : Writing [{token=[b34841b4-61fa-4dbb-9e2b-76496deb27b4]}] as "application/x-www-form-urlencoded"</span><br><span class="line">2021-11-03 16:40:11.332 ERROR 24652 --- [io2-2001-exec-4] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception</span><br><span class="line"></span><br><span class="line">org.springframework.web.client.ResourceAccessException: I/O error on POST request for "http://cas-server/oauth/check_token": cas-server; nested exception is java.net.UnknownHostException: cas-server</span><br><span class="line">at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:746)</span><br><span class="line">at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:672)</span><br><span class="line">at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:581)</span><br><span class="line">at org.springframework.security.oauth2.provider.token.RemoteTokenServices.postForMap(RemoteTokenServices.java:149)</span><br></pre></td></tr></tbody></table></figure><p>我们从上面的日志中，可以发现系统抛出 UnknownHostException 这种异常，无法找到<code>cas-server</code>，但我要说的是：我们这里用到的是Nacos注册中心来实现服务的注册与发现：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e496a5d43cce4561a6716c8ecabec914~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>那说明注册的服务可以被发现，接下来我们看支持 LB 的几种服务消费方式： RestTemplate、WebClient、Feign。<br>我们这里基于 Ribbon，RestTemplate，因为在Oauth2原生中，就是基于RestTemplate来调用远程服务：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String, Object&gt; postForMap(String path, MultiValueMap&lt;String, String&gt; formData, HttpHeaders headers) {</span><br><span class="line">if (headers.getContentType() == null) {</span><br><span class="line">headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);</span><br><span class="line">}</span><br><span class="line">@SuppressWarnings("rawtypes")</span><br><span class="line">Map map = restTemplate.exchange(path, HttpMethod.POST,</span><br><span class="line">new HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt;(formData, headers), Map.class).getBody();</span><br><span class="line">@SuppressWarnings("unchecked")</span><br><span class="line">Map&lt;String, Object&gt; result = map;</span><br><span class="line">return result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>大家都知道默认的原生Ribbon，是基于 RestTemplate 的负载均衡，所以这里配置如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@LoadBalanced</span><br><span class="line">@Bean</span><br><span class="line">public RestTemplate restTemplate() {</span><br><span class="line">        SimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();</span><br><span class="line">        requestFactory.setReadTimeout(env.getProperty("client.http.request.readTimeout", Integer.class, 15000));</span><br><span class="line">        requestFactory.setConnectTimeout(env.getProperty("client.http.request.connectTimeout", Integer.class, 3000));</span><br><span class="line">        RestTemplate rt = new RestTemplate(requestFactory);</span><br><span class="line">        return rt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，在定义 RestTemplate 的时候，增加了<code>@LoadBalanced</code>注解，但其实在真正调用服务接口的时候，原来host部分是通过手工拼接ip和端口的，直接采用服务名的时候来写请求路径即可。在真正调用的时候，Spring Cloud会将请求拦截下来，然后通过负载均衡器选出节点，并替换服务名为具体的ip和端口，从而实现基于服务名的负载均衡调用。</p><p>接下来，我们再看看负载均衡的策略是否有问题，Ribbon默认的负载均衡策略是<strong>轮询</strong>，内置了多种负载均衡策略，内置的负载均衡的顶级接口为<code>com.netflix.loadbalancer.IRule</code>。具体的策略有：AvailabilityFilteringRule、RoundRobinRule、RetryRule、RandomRule、WeightedResponseTimeRule、BestAvailableRule等。这里直接使用默认的<strong>轮询</strong>:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public IRule ribbonRule(IClientConfig config){</span><br><span class="line">            //return new AvailabilityFilteringRule();</span><br><span class="line">    return new RoundRobinRule();//轮询</span><br><span class="line">    //return new RetryRule();//重试</span><br><span class="line">            //return new RandomRule();//这里配置策略，和配置文件对应</span><br><span class="line">            //return new WeightedResponseTimeRule();//这里配置策略，和配置文件对应</span><br><span class="line">    //return new BestAvailableRule();//选择一个最小的并发请求的server</span><br><span class="line">    //return new MyProbabilityRandomRule();//自定义</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>到这里，目前都还未发现问题，那么既然实现了基于RestTemplate的负载均衡，为什么还是报错呢？</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bac955fa9c14e22bc000407f0c9147a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>找了半天，最后发现在Oauth2源码中，注入的是这么个玩意：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a056a19a7fd4d5884434dd97dac5adb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>这时候才发现多么的坑，于是乎，一顿猛操作：在资源检验时调用的覆盖其注入：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Autowired(required = true)</span><br><span class="line">private RemoteTokenServices remoteTokenServices;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">RestTemplate restTemplate;</span><br></pre></td></tr></tbody></table></figure><p>其二，直接set RestTemplate：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void configure(ResourceServerSecurityConfigurer resource) throws Exception {</span><br><span class="line">super.configure(resource);</span><br><span class="line"></span><br><span class="line">        restTemplate.setErrorHandler(new DefaultResponseErrorHandler() {</span><br><span class="line">            @Override</span><br><span class="line">            // Ignore 400</span><br><span class="line">            public void handleError(ClientHttpResponse response) throws IOException {</span><br><span class="line">                if (response.getRawStatusCode() != 400) {</span><br><span class="line">                    super.handleError(response);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        if (Objects.nonNull(remoteTokenServices)) {</span><br><span class="line">            remoteTokenServices.setRestTemplate(restTemplate);</span><br><span class="line">            resource.tokenServices(remoteTokenServices);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        resource</span><br><span class="line">        //.tokenStore(tokenStore)</span><br><span class="line">        //.tokenServices(tokenServices)</span><br><span class="line">        .authenticationEntryPoint(customAuthenticationEntryPoint)</span><br><span class="line">.accessDeniedHandler(customAccessDeniedHandler)</span><br><span class="line">        //.tokenExtractor(new BearerTokenExtractor())</span><br><span class="line">        ;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>接下来，我们重启消费端，看看效果，根据之前请求的token，直接访问消费端接口：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2021-11-03 16:57:50.476  INFO 81424 --- [io2-2001-exec-3] o.s.web.servlet.DispatcherServlet        : Completed initialization in 12 ms</span><br><span class="line">2021-11-03 16:57:50.522 DEBUG 81424 --- [io2-2001-exec-3] o.s.web.client.RestTemplate              : HTTP POST http://cas-server/oauth/check_token</span><br><span class="line">2021-11-03 16:57:50.526 DEBUG 81424 --- [io2-2001-exec-3] o.s.web.client.RestTemplate              : Accept=[application/json, application/*+json]</span><br><span class="line">2021-11-03 16:57:50.528 DEBUG 81424 --- [io2-2001-exec-3] o.s.web.client.RestTemplate              : Writing [{token=[b34841b4-61fa-4dbb-9e2b-76496deb27b4]}] as "application/x-www-form-urlencoded"</span><br><span class="line">2021-11-03 16:57:50.635 DEBUG 81424 --- [io2-2001-exec-3] o.s.web.client.RestTemplate              : Response 200 OK</span><br></pre></td></tr></tbody></table></figure><p>发现ok了，返回成功<code>200</code>，并且有权限访问该接口：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af71b380ca1546b79640fd3c60014d93~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>总结</p><p>有时候自己的代码写的已经很好了，但发现还是无法实现自己想要的：于是乎，可以大胆设想是不是官网源码出了幺蛾子，就像本文一样，如果不一步步检查，怎么也不会发现原来是源码留下如此大的坑，在前面的文章中，其实发现很多源码的不合理之处之后，都在修改，并且生成一套自己的规范返回，这样对于代码本身来说，我们会更加深刻体会、理解。Oauth2源码本身可以只是一个带头的基础功能，后面基于大项目，需要自己对于一些系统的设计进行改造，例如：高可用、高并发鉴权方案、统一认证SSO等等。</p><br><br><p><span class="suffix" style="display: none;"></span></p><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码:</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;">https://gitee.com/damon_one/spring-cloud-k8s</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">交个朋友之猿天地</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://xiao8.github.io" style="text-decoration: none" title="">交个朋友之猿天地 | 微服务 | 容器化 | 自动化</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：交个朋友之猿天地"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="后端" scheme="http://xiao8.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://xiao8.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>统一认证中心 Oauth2 认证坑</title>
    <link href="http://xiao8.github.io/2021/11/11/oauth2/"/>
    <id>http://xiao8.github.io/2021/11/11/oauth2/</id>
    <published>2021-11-11T07:11:21.000Z</published>
    <updated>2022-07-28T07:07:23.828Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在前面文章 <a href="https://xiao8.github.io/2021/10/11/oauth-ha/">Springcloud Oauth2 HA篇</a> 中，实现了基于 Oauth2 的统一认证的认证与授权。在配置中，我们可以看到：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cas-server-url: http://cas-server-service #这里配置成HA地址</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  oauth2: #与cas-server对应的配置</span><br><span class="line">    client:</span><br><span class="line">      client-id: admin-web</span><br><span class="line">      client-secret: admin-web-123</span><br><span class="line">      user-authorization-uri: ${cas-server-url}/oauth/authorize #是授权码认证方式需要的</span><br><span class="line">      access-token-uri: ${cas-server-url}/oauth/token #是密码模式需要用到的获取 token 的接口</span><br><span class="line">    resource:</span><br><span class="line">      loadBalanced: true</span><br><span class="line">      id: admin-web</span><br><span class="line">      user-info-uri: ${cas-server-url}/api/user #指定user info的URI</span><br><span class="line">      prefer-token-info: false</span><br></pre></td></tr></tbody></table></figure><p>这里的 url 配置是基于k8s的 Service，实现负载均衡，从而实现高可用。但我们接下来分析 user-info-uri。user-info-uri 的原理是在授权服务器认证后将认证信息 Principal 通过形参绑定的方法通过URL的方式获取用户信息。当然它也有配套的 UserInfoTokenService 等。</p><p>但这个在客户端获取用户权限时候，是存在一定问题的。譬如 Web端请求消费端的某个接口：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回发现的所有服务</span><br><span class="line"> * @author Damon</span><br><span class="line"> * @date 2021年11月2日 下午8:18:44</span><br><span class="line"> * @return</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@PreAuthorize("hasRole('admin')")</span><br><span class="line">@GetMapping(value = "/getService")</span><br><span class="line">    public String getService(){</span><br><span class="line">HttpHeaders headers = new HttpHeaders();</span><br><span class="line">MediaType type = MediaType.parseMediaType("application/json; charset=UTF-8");</span><br><span class="line">headers.setContentType(type);</span><br><span class="line">headers.add("Accept", MediaType.APPLICATION_JSON.toString());</span><br><span class="line">HttpEntity&lt;String&gt; formEntity = new HttpEntity&lt;String&gt;(null, headers);</span><br><span class="line">String body = "";</span><br><span class="line">try {</span><br><span class="line">ResponseEntity&lt;String&gt; responseEntity = restTemplate.exchange("http://cas-server/api/v1/user",</span><br><span class="line">HttpMethod.GET, formEntity, String.class);</span><br><span class="line">if (responseEntity.getStatusCodeValue() == 200) {</span><br><span class="line">return "ok";</span><br><span class="line">}</span><br><span class="line">} catch (Exception e) {</span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">}</span><br><span class="line">return body;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>在这个接口中，我们通过添加<code>@PreAuthorize("hasRole('admin')")</code>来控制权限，只要是admin的用户才能访问改接口。</p><p>我们先来请求认证中心登录接口，获取token：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eeb4bb0860054c15a2f03e781d165664~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>在拿到token之后，我们请求这个接口，我们会发现：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bbca89d4ba84ac0acc6dde997d279e7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>说明未认证，我们再看看：发现原来当请求这个接口时，消费端后去请求认证中心的接口：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2021-11-03 15:59:09.385 DEBUG 127896 --- [io2-2001-exec-4] org.springframework.web.HttpLogging      : HTTP GET http://cas-server/auth/user</span><br><span class="line">2021-11-03 15:59:09.389 DEBUG 127896 --- [io2-2001-exec-4] org.springframework.web.HttpLogging      : Accept=[application/json, application/*+json]</span><br><span class="line">2021-11-03 15:59:09.427 DEBUG 127896 --- [io2-2001-exec-4] org.springframework.web.HttpLogging      : Response 404 NOT_FOUND</span><br><span class="line">2021-11-03 15:59:09.446 DEBUG 127896 --- [io2-2001-exec-4] o.s.w.c.HttpMessageConverterExtractor    : Reading to [org.springframework.security.oauth2.common.exceptions.OAuth2Exception]</span><br><span class="line">2021-11-03 15:59:09.456  WARN 127896 --- [io2-2001-exec-4] o.s.b.a.s.o.r.UserInfoTokenServices      : Could not fetch user details: class org.springframework.web.client.HttpClientErrorException$NotFound, 404 : [{"timestamp":"2021-11-03T07:59:09.423+00:00","status":404,"error":"Not Found","message":"","path":"/auth/user"}]</span><br><span class="line">2021-11-03 15:59:09.457 ERROR 127896 --- [io2-2001-exec-4] c.l.h.CustomAuthenticationEntryPoint     : 无效的token，请重新认证访问</span><br><span class="line">{"data":"b34841b4-61fa-4dbb-9e2b-76496deb27b4","result":{"code":20202,"msg":"未认证","status":401}}</span><br></pre></td></tr></tbody></table></figure><p>但认证中心给返回的<code>404</code>状态码，此时会走统一异常EntryPoint提示报错：<code>无效的token，请重新认证访问</code>。从而返回信息体：<code>{"data":"b34841b4-61fa-4dbb-9e2b-76496deb27b4","result":{"code":20202,"msg":"未认证","status":401}}</code>。</p><p>接下来分析：为什么认证中心会返回<code>404</code>呢？看认证中心日志：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2021-11-03 15:59:09.407 DEBUG 54492 --- [o2-2000-exec-15] o.s.web.servlet.DispatcherServlet        : GET "/auth/user", parameters={}</span><br><span class="line">2021-11-03 15:59:09.409 DEBUG 54492 --- [o2-2000-exec-15] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped to ResourceHttpRequestHandler ["classpath:/META-INF/resources/", "classpath:/resources/", "classpath:/static/", "classpath:/public/"]</span><br><span class="line">2021-11-03 15:59:09.413 DEBUG 54492 --- [o2-2000-exec-15] o.s.w.s.r.ResourceHttpRequestHandler     : Resource not found</span><br><span class="line">2021-11-03 15:59:09.414 DEBUG 54492 --- [o2-2000-exec-15] o.s.web.servlet.DispatcherServlet        : Completed 404 NOT_FOUND</span><br><span class="line">2021-11-03 15:59:09.422 DEBUG 54492 --- [o2-2000-exec-15] o.s.web.servlet.DispatcherServlet        : "ERROR" dispatch for GET "/error", parameters={}</span><br><span class="line">2021-11-03 15:59:09.423 DEBUG 54492 --- [o2-2000-exec-15] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped to org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController#error(HttpServletRequest)</span><br><span class="line">2021-11-03 15:59:09.424 DEBUG 54492 --- [o2-2000-exec-15] o.s.w.s.m.m.a.HttpEntityMethodProcessor  : Using 'application/json', given [application/json] and supported [application/json, application/*+json, application/json, application/*+json, application/json, application/*+json]</span><br><span class="line">2021-11-03 15:59:09.424 DEBUG 54492 --- [o2-2000-exec-15] o.s.w.s.m.m.a.HttpEntityMethodProcessor  : Writing [{timestamp=Wed Nov 03 15:59:09 CST 2021, status=404, error=Not Found, message=, path=/auth/user}]</span><br><span class="line">2021-11-03 15:59:09.426 DEBUG 54492 --- [o2-2000-exec-15] o.s.web.servlet.DispatcherServlet        : Exiting from "ERROR" dispatch, status 404</span><br></pre></td></tr></tbody></table></figure><p>发现原来Oauth2没有此类接口:<code>/auth/user</code>。最后决定自写一个接口来替换原生:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping("/api/v1/user")</span><br><span class="line">    public Authentication user(Map map, Principal user, Authentication auth) {</span><br><span class="line">        //获取当前用户信息</span><br><span class="line">    logger.info("cas-server provide user: " + JSON.toJSONString(auth));</span><br><span class="line">        return auth;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>在封装、覆盖后，在消费端直接配置相关配置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cas-server-url: http://cas-server</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  path:</span><br><span class="line">    ignores: /,/index,/static/**,/css/**, /image/**, /favicon.ico, /js/**,/plugin/**,/avue.min.js,/img/**,/fonts/**</span><br><span class="line">  oauth2:</span><br><span class="line">    client:</span><br><span class="line">      client-id: rest-service</span><br><span class="line">      client-secret: rest-service-123</span><br><span class="line">      user-authorization-uri: ${cas-server-url}/oauth/authorize</span><br><span class="line">      access-token-uri: ${cas-server-url}/oauth/token</span><br><span class="line">    resource:</span><br><span class="line">      loadBalanced: true</span><br><span class="line">      id: rest-service</span><br><span class="line">      prefer-token-info: false</span><br><span class="line">      user-info-uri: ${cas-server-url}/api/v1/user</span><br><span class="line">    authorization:</span><br><span class="line">      check-token-access: ${cas-server-url}/oauth/check_token</span><br></pre></td></tr></tbody></table></figure><p>同时启动认证中心、消费端，继续获取token后，请求接口：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29428df6a1234d6da3e94f6911dd5c38~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>此时，发现是<code>403</code>，没有权限了，这下我们可以对用户添加这种权限即可：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"authorities": [ { "authority": "ROLE_admin" }, { "authority": "admin" }</span><br></pre></td></tr></tbody></table></figure><p>添加完之后，我们发现可以请求接口成功：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">{ "authorities": [ { "authority": "ROLE_admin" }, { "authority": "admin" } ], "details": { "remoteAddress": "0:0:0:0:0:0:0:1", "sessionId": null, "tokenValue": "b34841b4-61fa-4dbb-9e2b-76496deb27b4", "tokenType": "bearer", "decodedDetails": null }, "authenticated": true, "userAuthentication": { "authorities": [ { "authority": "ROLE_admin" }, { "authority": "admin" } ], "details": { "authorities": [ { "authority": "ROLE_admin" }, { "authority": "admin" } ], "details": { "remoteAddress": "169.254.200.12", "sessionId": null, "tokenValue": "b34841b4-61fa-4dbb-9e2b-76496deb27b4", "tokenType": "Bearer", "decodedDetails": null }, "authenticated": true, "userAuthentication": { "authorities": [ { "authority": "ROLE_admin" }, { "authority": "admin" } ],</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>这里简单测试，直接写的返回当前用户权限的接口，发现权限就是”ROLE_admin、”admin”。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有时候官网的源码解析很少，我们必须看源码，结合实际行动才能准确的分析其用意。所以当其不存在、或者不满足我们的需求时，可以选择覆盖其源码逻辑，实现自定义模式，这样会避免很多不必要的麻烦。因为源码解析毕竟不同版本，对应的源码也是不同的。</p><br><br><p><span class="suffix" style="display: none;"></span></p><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码:</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;">https://gitee.com/damon_one/spring-cloud-k8s</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">交个朋友之猿天地</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://xiao8.github.io" style="text-decoration: none" title="">交个朋友之猿天地 | 微服务 | 容器化 | 自动化</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：交个朋友之猿天地"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="后端" scheme="http://xiao8.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://xiao8.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>基于 spring-cloud-k8s 跨NS坑续集</title>
    <link href="http://xiao8.github.io/2021/11/11/spring-cloud-k8s-note2/"/>
    <id>http://xiao8.github.io/2021/11/11/spring-cloud-k8s-note2/</id>
    <published>2021-11-11T07:07:51.000Z</published>
    <updated>2022-07-28T07:07:24.406Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在前面文章 (<a href="https://xiao8.github.io/2021/11/11/spring-cloud-k8s-note1/">spring-cloud-k8s 跨 NS 的坑</a>) 中，讲述了 <code>spring-cloud-k8s</code> 中，如何利用 k8s 基于 Ribbon 等负载均衡利器来实现 LB，但存在<code>跨命名空间</code>的问题。</p><p>今天主要分享的是，基于 K8s 本身的 LB 利器，如何实现跨命名空间的应用服务互相访问，而且不是通过 K8s 原生的负载均衡 url 方式。还是基于 ServiceName。</p><h3 id="直击源码"><a href="#直击源码" class="headerlink" title="直击源码"></a>直击源码</h3><p>首先，我们新建一个服务提供者:<code>diff-ns-service</code>，该服务提供了一个接口：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回远程调用的结果</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@RequestMapping("/getservicedetail")</span><br><span class="line">public String getservicedetail(</span><br><span class="line">        @RequestParam(value = "servicename", defaultValue = "") String servicename) {</span><br><span class="line">    return JSON.toJSONString(discoveryClient.getInstances(servicename));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>该接口的功能是返回指定 service 的相关信息。比如：这个 Service 对应的有几个 pod，每个 pod 的节点信息，host 等。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a735bc6e831949619b1ae69cd22309ab~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>如果想结合 K8s 来实现这个服务的发现，可以基于这个配置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">management:</span><br><span class="line">  endpoint:</span><br><span class="line">    restart:</span><br><span class="line">      enabled: true</span><br><span class="line">    health:</span><br><span class="line">      enabled: true</span><br><span class="line">    info:</span><br><span class="line">      enabled: true</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: diff-ns-service</span><br><span class="line">  cloud:</span><br><span class="line">    loadbalancer:</span><br><span class="line">      ribbon:</span><br><span class="line">        enabled: false</span><br><span class="line">    kubernetes:</span><br><span class="line">      ribbon:</span><br><span class="line">        mode: SERVICE</span><br><span class="line">      discovery:</span><br><span class="line">        all-namespaces: true</span><br></pre></td></tr></tbody></table></figure><p>另外，如果想利用 k8s configMap 的配置来实现动态刷新应用服务的环境配置，可以这样配置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: diff-ns-service</span><br><span class="line">  cloud:</span><br><span class="line">    kubernetes:</span><br><span class="line">      reload:</span><br><span class="line">        enabled: true</span><br><span class="line">        strategy: refresh</span><br><span class="line"></span><br><span class="line">        mode: event</span><br><span class="line">      config:</span><br><span class="line">        name: ${spring.application.name}</span><br><span class="line">        namespace: default</span><br><span class="line">        sources:</span><br><span class="line">          - name: ${spring.application.name}</span><br><span class="line">            namespace: ns-app</span><br></pre></td></tr></tbody></table></figure><p>这里的动态刷新的模式有两个：<code>[polling</code>、<code>event</code>。一个是主动拉取，一个是当 configmap 发生改变时，这种事件会被监听到，会主动刷新。</p><p>另外，这个刷新的策略也有几种：</p><ul><li>refresh，直接刷新</li><li>restart_context，整个 Spring Context 会优雅重启，里面的所有配置都会重新加载</li><li>shutdown，重启容器</li></ul><p>这样，我们再来配置一下 Service：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: diff-ns-service-service</span><br><span class="line">  namespace: ns-app</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - name: diff-ns-svc</span><br><span class="line">    port: 2008</span><br><span class="line">    targetPort: 2001</span><br><span class="line">  selector:</span><br><span class="line">    app: diff-ns-service</span><br></pre></td></tr></tbody></table></figure><p>这里我们设置了 Service 的 port,并且这个 Service 以 <code>NodePort</code> 类型创建。在(<a href="https://juejin.cn/post/7028718715399061534">spring-cloud-k8s 跨 NS 的坑</a>)一文中，我们使用的是默认的类型：ClusterIp。</p><p>这样，一个简单的服务提供者就创建成功了。接下来，我们看看服务消费者。</p><p>同样，我们先来创建一个服务 <code>rest-service</code>，创建接口：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping("/getClientRes")</span><br><span class="line">public Response&lt;Object&gt; getClientRes() throws Exception {</span><br><span class="line">        HttpHeaders headers = new HttpHeaders();</span><br><span class="line">        MediaType type = MediaType.parseMediaType("application/json; charset=UTF-8");</span><br><span class="line">        headers.setContentType(type);</span><br><span class="line">        headers.add("Accept", MediaType.APPLICATION_JSON.toString());</span><br><span class="line">        HttpEntity&lt;String&gt; formEntity = new HttpEntity&lt;String&gt;(null, headers);</span><br><span class="line">        String body = "";</span><br><span class="line">        try {</span><br><span class="line">                ResponseEntity&lt;String&gt; responseEntity = restTemplate.exchange("http://diff-ns-service-service/getservicedetail?servicename=cas-server-service",</span><br><span class="line">                                HttpMethod.GET, formEntity, String.class);</span><br><span class="line">                System.out.println(JSON.toJSONString(responseEntity));</span><br><span class="line">                if (responseEntity.getStatusCodeValue() == 200) {</span><br><span class="line">                        return Response.ok(responseEntity.getBody());</span><br><span class="line">                }</span><br><span class="line">        } catch (Exception e) {</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">        }</span><br><span class="line">        return Response.error("failed");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同理地，结合 K8s 来实现这个服务的发现，可以基于这个配置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">management:</span><br><span class="line">  endpoint:</span><br><span class="line">    restart:</span><br><span class="line">      enabled: true</span><br><span class="line">    health:</span><br><span class="line">      enabled: true</span><br><span class="line">    info:</span><br><span class="line">      enabled: true</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: rest-service</span><br><span class="line">  cloud:</span><br><span class="line">    loadbalancer:</span><br><span class="line">      ribbon:</span><br><span class="line">        enabled: false</span><br><span class="line">    kubernetes:</span><br><span class="line">      ribbon:</span><br><span class="line">        mode: SERVICE</span><br><span class="line">      discovery:</span><br><span class="line">        all-namespaces: true</span><br></pre></td></tr></tbody></table></figure><p>这里，我们不使用 RibbonLoadBalancerClient。</p><p>另外，如果想利用 k8s configMap 的配置来实现动态刷新应用服务的环境配置，可以这样配置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    kubernetes:</span><br><span class="line">      reload:</span><br><span class="line">        enabled: true</span><br><span class="line">        strategy: refresh</span><br><span class="line"></span><br><span class="line">        mode: event</span><br><span class="line">      config:</span><br><span class="line">        name: ${spring.application.name}</span><br><span class="line">        namespace: default</span><br><span class="line">        sources:</span><br><span class="line">          - name: ${spring.application.name}</span><br><span class="line">            namespace: system-server</span><br></pre></td></tr></tbody></table></figure><p>对于这些，在前面的文章说过，我们需要依赖配置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-actuator-autoconfigure&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-kubernetes&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-starter-kubernetes-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-kubernetes-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-kubernetes-loadbalancer&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;okhttp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure><p>这里没有用 Ribbon 的，直接使用 <code>spring-cloud-starter-kubernetes-loadbalancer</code>，但我们还是利用 <code>RestTemplate</code>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@LoadBalanced</span><br><span class="line">@Bean</span><br><span class="line">public RestTemplate restTemplate() {</span><br><span class="line">        SimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();</span><br><span class="line">        requestFactory.setReadTimeout(env.getProperty("client.http.request.readTimeout", Integer.class, 15000));</span><br><span class="line">        requestFactory.setConnectTimeout(env.getProperty("client.http.request.connectTimeout", Integer.class, 3000));</span><br><span class="line">        RestTemplate rt = new RestTemplate(requestFactory);</span><br><span class="line">        return rt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来，我们开始部署这两个应用服务了，同时，我们采用服务扩容方式实现多 pod：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale --replicas=2 deployment diff-ns-service-deployment</span><br></pre></td></tr></tbody></table></figure><p>我们苦役看看服务节点信息：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f99a4ba585c74385aeb79c57595ad743~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>查看 Service 信息：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4df1129a9e54c99bd48cf90516e778e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>接下来，我们访问服务<code>rest-service</code>：<a href="http://192.168.8.107:5556/rest-service/getClientRes%EF%BC%8C">http://192.168.8.107:5556/rest-service/getClientRes，</a> 这里我们可以看到日志：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33e6101356114bb6864689edc3d5193f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>同时，去哦们可以看到返回结果：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc8a5a4e63aa4b9da4c69ed9ad0567b7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>这里，我们请求的是获取<code>cas-server</code> 这个服务的 pod 的分布信息。</p><p>同样地，我们通过 Service 的 Ip 和端口也可以直接访问：<code>http://192.168.8.107:30916/getservicedetail?servicename=cas-server-service</code></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/625abd4fde7f429a8c4ada4864d68b3c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>PS:如果需要实现负载均衡，还是需要注入：<code>@LoadBalanced</code>，如果我们把这个注解去掉会发生什么呢？</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53081b6de743497b871f117851d95e10~tplv-k3u1fbpfcp-watermark.image" alt="1636538633(1).png"></p><p>我们发现去掉后，竟然不能访问了。</p><p>我们再做一组测试，如果我们利用 <code>spring.cloud.kubernetes.ribbon.mode=POD</code>，我们来看看会有啥结果不？<br>修改配置后，重新编译、部署，我们继续请求 url<code>http://192.168.8.107:5556/rest-service/getClientRes</code>:</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80a005f867ba421882147f61f61bf7b7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="新发现"><a href="#新发现" class="headerlink" title="新发现"></a>新发现</h3><p>如果我们引入的是基于 Spring cloud 本身的<code>spring-cloud-starter-kubernetes-loadbalancer</code>，同时，我们没有去掉基于 Ribbon 的 LB 的能力，如：<code>spring.cloud.loadbalancer.ribbon.enabled=false</code>，是有可能会报错的：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3b5ff9c059045d4b89f987d11e5474f~tplv-k3u1fbpfcp-watermark.image" alt="1636601324.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>Spring cloud 本身：如果是基于 Spring cloud 本身的 LB，需要隐藏 Ribbon 的能力，同时基于<code>RestTemplate</code> 需要注解<code>@LoadBalanced</code>。</p></li><li><p>k8s 本身：如果采用 Spring cloud 的负载，再结合 K8s，可以实现应用服务的 LB。如果设置<code>spring.cloud.kubernetes.ribbon.mode=POD</code>，其禁用了 Ribbon 的 LB 能力，此时不会生效，走的还是 Spring cloud LoadBalancer。另外对于 Service，这里都设置为 NodePort 类型，如果是默认类型是否可以实现 LB，需要待确认，因为目前来看，没有实现，可能是网络问题，并不是说默认类型的 Service 不可实现 LB。</p></li><li><p>Ribbon，基于上面，下次可以尝试基于 NodePort 类型的 Service 来实现 Ribbon 的 LB，看是否是因为 Service 的网络导致的。</p></li></ul><h3 id="实践验证"><a href="#实践验证" class="headerlink" title="实践验证"></a>实践验证</h3><p>在前面我们已经针对默认类型的Service进行Ribbon负载均衡测试过，发现无法对跨 NS 进行LB。接下来，我们测试下基于 NodePort 类型的Service，打开<code>spring.cloud.loadbalancer.ribbon.enabled=true</code>，引入依赖：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-kubernetes-ribbon&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure><p>按照以上配置，我们部署服务<code>diff-ns-service</code>，我们发现服务启动后日志：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db0f5a1280e645fb88909b39aa3be35c~tplv-k3u1fbpfcp-watermark.image" alt="1636603546(1).png"></p><p>请求后返回日志：<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2975fc0433b40dd8424d07c7583ef7c~tplv-k3u1fbpfcp-watermark.image" alt="1636603299(1).png"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>不管怎样，Ribbon 无法解决跨 NS 的应用服务之间的相互访问。但对于 Service 类型来说，可能是网络设置问题，跟其类型无关。</p><br><br><p><span class="suffix" style="display: none;"></span></p><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码:</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;">https://gitee.com/damon_one/spring-cloud-k8s</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">交个朋友之猿天地</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://xiao8.github.io" style="text-decoration: none" title="">交个朋友之猿天地 | 微服务 | 容器化 | 自动化</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：交个朋友之猿天地"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="后端" scheme="http://xiao8.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://xiao8.github.io/tags/Java/"/>
    
    <category term="后端" scheme="http://xiao8.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="K8s" scheme="http://xiao8.github.io/tags/K8s/"/>
    
  </entry>
  
  <entry>
    <title>spring-cloud-k8s 跨 NS 的坑</title>
    <link href="http://xiao8.github.io/2021/11/11/spring-cloud-k8s-note1/"/>
    <id>http://xiao8.github.io/2021/11/11/spring-cloud-k8s-note1/</id>
    <published>2021-11-11T07:06:15.000Z</published>
    <updated>2022-07-28T07:07:22.205Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>前面文章 (<a href="https://xiao8.github.io/2020/07/23/spring-cloud-k8s-discovery/">Spring Cloud Kubernetes 之实战服务注册与发现</a>) 中，讲述了 <code>spring-cloud-k8s</code> 在微服务实践中，带来了多大的优势。介绍了 k8s 中资源 Service，其如何来实现服务的注册与发现。</p><p>其实在 k8s 中，Service 资源的类型比较多，有四种：</p><ul><li>ExternalName：创建一个 DNS 别名指向 service name，这样可以防止 service name 发生变化，但需要配合 DNS 插件使用。</li><li>ClusterIP：默认的类型，用于为集群内 Pod 访问时，提供的固定访问地址,默认是自动分配地址,可使用 ClusterIP 关键字指定固定 IP。</li><li>NodePort：基于 ClusterIp，用于为集群外部访问 Service 后面 Pod 提供访问接入端口。</li><li>LoadBalancer：它是基于 NodePort。</li></ul><p>我们一般会默认使用的类型：ClusterIP，但此时会出现一种问题，那就是此类型的 Service 被用来访问非同一 NS 下的 pods，即<code>&lt;servicename&gt;.&lt;namespace&gt;.svc.cluster.local</code>形式访问 pod，只能通过 servicename 直接访问同一 namespace 下的 pod。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>下面，我们来看案例：假设我这里有三个服务：cas-server、rest-service、diff-ns-service 等，我通过 deployment 来部署这些服务的 pod。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2950309ca46a4cbaa608fb1c22e8ca3a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>可以看到这些 pod 处于 不同的 namespace 下，同样的对应的 service 也是处于对应的 namespace 下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ns-app          diff-ns-service-service   ClusterIP   10.16.178.187   &lt;none&gt;        2008/TCP        6h39m   app=diff-ns-service</span><br><span class="line">system-server   cas-server-service        ClusterIP   10.16.134.168   &lt;none&gt;        2000/TCP        16d     app=cas-server</span><br><span class="line">system-server   rest-service-service      ClusterIP   10.16.128.58    &lt;none&gt;        2001/TCP        16d     app=rest-service</span><br></pre></td></tr></tbody></table></figure><p>这里的 Service 类型都是 <code>ClusterIp</code>,在前面，我们验证过基于这样的服务，我们可以利用 springcloud-k8s 来实现同一 namespace 下服务之间的注册与发现，实现负载均衡。但如果不在同一 namespace 下呢？比如这里的<code>diff-ns-service</code>，它与另外两个服务不在同一 namespace。此时我们通过基于 Ribbon 的负载均衡策略。这是因为我们默认了 <code>KubernetesRibbonMode</code> 的模式：POD，就是获取服务提供者的 pod 的 ip 和 port，该 ip 是 kubernetes 集群的内部 ip，只要服务消费者是部署在同一个 kubernetes 集群内就能通过 pod 的 ip 和服务提供者暴露的端口访问。当我们使用当<code>mode</code>为<code>SERVICE</code>时，就是获取服务提供者在 k8s 中的 service 的名称和端口，使用这种模式会导致 Ribbon 的负载均衡失效，转而使用 k8s 的负载均衡。</p><p>所以，如果不使用默认的 Ribbon 来实现负载均衡，可以配置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    kubernetes:</span><br><span class="line">      ribbon:</span><br><span class="line">        mode: SERVICE</span><br></pre></td></tr></tbody></table></figure><p>这个前提其实还是在同一 namespace 下，但如果不在同一 NS 呢？还是设置为<code>SERVICE</code>模式，但里面还是用 k8s 原生的调用方式：<code>&lt;servicename&gt;.&lt;namespace&gt;.svc.cluster.local***</code>，假设这里需要调用 <code>diff-ns-service</code>,则：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;String&gt; responseEntity = new RestTemplate().exchange("http://diff-ns-service-service/getservicedetail?servicename=cas-server-service",</span><br><span class="line">HttpMethod.GET, formEntity, String.class);</span><br></pre></td></tr></tbody></table></figure><p>访问请求该服务时，发现并未请求到：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2021-11-04 09:23:16.830:147 [http-nio2-2001-exec-2] DEBUG org.springframework.web.client.RestTemplate -HTTP GET http://diff-ns-service-service/getservicedetail?servicename=cas-server-service</span><br><span class="line">2021-11-04 09:23:16.834:147 [http-nio2-2001-exec-2] DEBUG org.springframework.web.client.RestTemplate -Accept=[text/plain, application/json, application/*+json, */*]</span><br><span class="line">2021-11-04 09:23:16.859:255 [http-nio2-2001-exec-2] DEBUG org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor -Using 'text/html', given [text/html, application/xhtml+xml, image/avif, image/webp, image/apng, application/xml;q=0.9, application/signed-exchange;v=b3;q=0.9, */*;q=0.8] and supported [text/plain, */*, text/plain, */*, application/json, application/*+json, application/json, application/*+json]</span><br><span class="line">2021-11-04 09:23:16.860:91 [http-nio2-2001-exec-2] DEBUG org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor -Writing [""]</span><br></pre></td></tr></tbody></table></figure><p>如果走 mode 为<code>POD</code>的 Ribbon 的负载均衡：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2021-11-04 09:34:32.188:147 [http-nio2-2001-exec-2] DEBUG org.springframework.web.client.RestTemplate -HTTP GET http://diff-ns-service-service/getservicedetail?servicename=cas-server-service</span><br><span class="line">2021-11-04 09:34:32.193:147 [http-nio2-2001-exec-2] DEBUG org.springframework.web.client.RestTemplate -Accept=[text/plain, application/json, application/*+json, */*]</span><br><span class="line">2021-11-04 09:34:32.261:115 [http-nio2-2001-exec-2] INFO  com.netflix.config.ChainedDynamicProperty -Flipping property: diff-ns-service-service.ribbon.ActiveConnectionsLimit to use NEXT property: niws.loadbalancer.availabilityFilteringRule.activeConnectionsLimit = 2147483647</span><br><span class="line">2021-11-04 09:34:32.271:197 [http-nio2-2001-exec-2] INFO  com.netflix.loadbalancer.BaseLoadBalancer -Client: diff-ns-service-service instantiated a LoadBalancer: DynamicServerListLoadBalancer:{NFLoadBalancer:name=diff-ns-service-service,current list of Servers=[],Load balancer stats=Zone stats: {},Server stats: []}ServerList:null</span><br><span class="line">2021-11-04 09:34:32.278:222 [http-nio2-2001-exec-2] INFO  com.netflix.loadbalancer.DynamicServerListLoadBalancer -Using serverListUpdater PollingServerListUpdater</span><br><span class="line">2021-11-04 09:34:32.281:88 [http-nio2-2001-exec-2] WARN  org.springframework.cloud.kubernetes.ribbon.KubernetesEndpointsServerList -Did not find any endpoints in ribbon in namespace [system-server] for name [diff-ns-service-service] and portName [null]</span><br><span class="line">2021-11-04 09:34:32.282:150 [http-nio2-2001-exec-2] INFO  com.netflix.loadbalancer.DynamicServerListLoadBalancer -DynamicServerListLoadBalancer for client diff-ns-service-service initialized: DynamicServerListLoadBalancer:{NFLoadBalancer:name=diff-ns-service-service,current list of Servers=[],Load balancer stats=Zone stats: {},Server stats: []}ServerList:org.springframework.cloud.kubernetes.ribbon.KubernetesEndpointsServerList@d48bf01</span><br><span class="line">2021-11-04 09:34:32.308:255 [http-nio2-2001-exec-2] DEBUG org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor -Using 'text/html', given [text/html, application/xhtml+xml, image/avif, image/webp, image/apng, application/xml;q=0.9, application/signed-exchange;v=b3;q=0.9, */*;q=0.8] and supported [text/plain, */*, text/plain, */*, application/json, application/*+json, application/json, application/*+json]</span><br><span class="line">2021-11-04 09:34:32.309:91 [http-nio2-2001-exec-2] DEBUG org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor -Writing [""]</span><br><span class="line">2021-11-04 09:34:32.316:1131 [http-nio2-2001-exec-2] DEBUG org.springframework.web.servlet.DispatcherServlet -Completed 200 OK</span><br></pre></td></tr></tbody></table></figure><p>此时，给我的感觉就是：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    kubernetes:</span><br><span class="line">      ribbon:</span><br><span class="line">        #直接走k8s的LB</span><br><span class="line">        mode: SERVICE #POD走ribbon的LB</span><br><span class="line">      discovery:</span><br><span class="line">        all-namespaces: true</span><br></pre></td></tr></tbody></table></figure><p>此类配置是无法进行 Service 到应用服务的访问，只能访问到 Service。同时我们看到日志：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021-11-04 09:34:32.281:88 [http-nio2-2001-exec-2] WARN  org.springframework.cloud.kubernetes.ribbon.KubernetesEndpointsServerList -Did not find any endpoints in ribbon in namespace [system-server] for name [diff-ns-service-service] and portName [null]</span><br></pre></td></tr></tbody></table></figure><p>上面给到的是 mode 为 POD 时，走的 Ribbon 的负载均衡后，无法找到当前 pod 对应的 NS 下的 Servcie 为 diff-ns-service-service 的服务。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021-11-04 09:20:27.109:89 [PollingServerListUpdater-1] WARN  org.springframework.cloud.kubernetes.ribbon.KubernetesServicesServerList -Did not find any service in ribbon in namespace [system-server] for name [diff-ns-service-service] and portName [null]</span><br></pre></td></tr></tbody></table></figure><p>同样地，当 mode 为 SERVICE 时，依然无法找到当前 pod 的对应的 NS 的 Servcie 为 diff-ns-service-service 的服务。</p><p>同样会拿不到请求返回信息，这里说明：<code>在不同NS下，Service为ClusterIP，不管如何负载均衡，都无法访问。</code></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h4 id="一、通过-Springcloud-k8s-社区来实现跨-NS-下的服务的相互访问的简单策略"><a href="#一、通过-Springcloud-k8s-社区来实现跨-NS-下的服务的相互访问的简单策略" class="headerlink" title="一、通过 Springcloud k8s 社区来实现跨 NS 下的服务的相互访问的简单策略"></a>一、通过 Springcloud k8s 社区来实现跨 NS 下的服务的相互访问的简单策略</h4><h4 id="二、走-K8s-的原生的负载均衡策略"><a href="#二、走-K8s-的原生的负载均衡策略" class="headerlink" title="二、走 K8s 的原生的负载均衡策略"></a>二、走 K8s 的原生的负载均衡策略</h4><p>从前面的分析可以看到：虽然 spring-cloud-k8s 帮我们发现了 Service，但在底层策略时，不同的NS还是做了隔离，只能通过 k8s 原生的方式来进行服务的发现：<code>&lt;servicename&gt;.&lt;namespace&gt;.svc.cluster.local</code></p><p>PS：<code>同时，我们需要注意的是，此时基于 k8s 负载均衡，我们不能再基于 Ribbon 或其他来进行负载均衡机制了，直接通过 Http 协议来请求 k8s 的 service，实现跨 NS 的 pod 之间的互通。</code></p><br><br><p><span class="suffix" style="display: none;"></span></p><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码:</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;">https://gitee.com/damon_one/spring-cloud-k8s</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">交个朋友之猿天地</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://xiao8.github.io" style="text-decoration: none" title="">交个朋友之猿天地 | 微服务 | 容器化 | 自动化</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：交个朋友之猿天地"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="后端" scheme="http://xiao8.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://xiao8.github.io/tags/Java/"/>
    
    <category term="后端" scheme="http://xiao8.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="K8s" scheme="http://xiao8.github.io/tags/K8s/"/>
    
  </entry>
  
  <entry>
    <title>Springcloud Oauth2 HA篇</title>
    <link href="http://xiao8.github.io/2021/10/11/oauth-ha/"/>
    <id>http://xiao8.github.io/2021/10/11/oauth-ha/</id>
    <published>2021-10-11T07:17:58.000Z</published>
    <updated>2022-07-28T07:07:24.622Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 <a href="https://juejin.cn/post/6970882539820941325">浅谈微服务安全架构设计</a> 一文中，介绍了基于Springcloud 结合了Oauth2分析了其各种模式下的鉴权认证，今天主要分析如何结合k8s作实现鉴权的高可用。</p><p>假设我们的项目中有几个模块：</p><ul><li>鉴权中心：Oauth2服务</li><li>订单系统：客户端A</li><li>用户管理系统：客户端B</li></ul><p>在上面的系统中，每个服务之间的耦合性很低，但是又有着很频繁的调用，这就涉及到UI与其之间的频繁流量交互。如何做到其HA，这里引入k8s的Service方法：</p><p>在 <a href="https://juejin.cn/post/6974562663833534494">Spring Cloud Kubernetes之实战服务注册与发现</a>一文中，就讲解了k8s的Service方式创建服务，然后可以部署多个pod，同时结合 <a href="https://juejin.cn/post/6977498328153980959">Spring Cloud Kubernetes之实战网关Gateway</a> 来实现LB，类似通过域名来解析其服务，并根据所定义的规则进行LB。同样，本文则是Oauth2的基础上，结合这些来实现微服务的LB。同时此处利用了k8s来作主要处理，如果是其他语言(Python、Go、Rust等)的客户端服务，则自身可以通过逻辑来控制其鉴权以及获取流量的。</p><p><code>注意点：由于各微服务与鉴权中心有交互，故鉴权中心需要提供HA服务，即先在启动类加入@EnableDiscoveryClient ，后续在注入bean时，@LoadBalanced来实现LB鉴权中心。</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@EnableOAuth2Sso</span><br><span class="line">@Configuration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(basePackages = {"com.damon"})</span><br><span class="line">@EnableConfigurationProperties(EnvConfig.class)</span><br><span class="line">@EnableDiscoveryClient #为LB多节点鉴权中心准备</span><br><span class="line">public class AdminApp {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        SpringApplication.run(AdminApp.class, args);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在客户端项目模块中，调用鉴权中心时，需要实现LB：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class BeansConfig {</span><br><span class="line">  @Resource</span><br><span class="line">  private Environment env;</span><br><span class="line"></span><br><span class="line">  @LoadBalanced</span><br><span class="line">  @Bean</span><br><span class="line">  public RestTemplate restTemplate() {</span><br><span class="line">    SimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();</span><br><span class="line">    requestFactory.setReadTimeout(env.getProperty("client.http.request.readTimeout", Integer.class, 15000));</span><br><span class="line">    requestFactory.setConnectTimeout(env.getProperty("client.http.request.connectTimeout", Integer.class, 3000));</span><br><span class="line">    RestTemplate rt = new RestTemplate(requestFactory);</span><br><span class="line">    return rt;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>另外本身在配置交互的时候，需要加上域名等形式来实现LB，这里利用了k8s的Service来实现。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cas-server-url: http://cas-server-service #这里配置成HA地址</span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  oauth2: #与cas-server对应的配置</span><br><span class="line">    client:</span><br><span class="line">      client-id: admin-web</span><br><span class="line">      client-secret: admin-web-123</span><br><span class="line">      user-authorization-uri: ${cas-server-url}/oauth/authorize #是授权码认证方式需要的</span><br><span class="line">      access-token-uri: ${cas-server-url}/oauth/token #是密码模式需要用到的获取 token 的接口</span><br><span class="line">    resource:</span><br><span class="line">      loadBalanced: true</span><br><span class="line">      id: admin-web</span><br><span class="line">      user-info-uri: ${cas-server-url}/api/user #指定user info的URI</span><br><span class="line">      prefer-token-info: false</span><br></pre></td></tr></tbody></table></figure><p>这样，一个客户端关于鉴权的核心就是如此了，同样需要把消费客户端以service形式提供给UI，此时需要借助 <a href="">Spring Cloud Kubernetes之实战网关Gateway</a> 和nginx代理服务，我们来测试下：<code>curl -X POST -d "username=admin&amp;password=123456&amp;grant_type=password&amp;client_id=admin-web&amp;client_secret=admin-web-123" http://192.168.8.10:5556/cas-server/oauth/token</code></p><p>看到结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{"access_token":"5a7892b0-7483-4f60-89fd-44255a429ff6","token_type":"bearer","refresh_token":"23f2e8ea-f091-4ab0-822c-f28bebc4ec08","expires_in":3599,"scope":"all"}</span><br></pre></td></tr></tbody></table></figure><p>通过获取到的access_token来访问对应的客户端：<code>curl -H "Accept: application/json" -H "Authorization:bearer 5a7892b0-7483-4f60-89fd-44255a429ff6" -X GET http://192.168.8.10:5556/admin-web/api/user/getCurrentUser</code></p><p>输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{"authorities":[{"authority":"admin"}],"details":{"remoteAddress":"10.244.0.196","sessionId":null,"tokenValue":"5a7892b0-7483-4f60-89fd-44255a429ff6","tokenType":"bearer","decodedDetails":null},"authenticated":true,"userAuthentication":{"authorities":[{"authority":"admin"}],"details":{"authorities":[{"authority":"admin"}],"details":{"remoteAddress":"10.244.0.201","sessionId":null,"tokenValue":"5a7892b0-7483-4f60-89fd-44255a429ff6","tokenType":"Bearer","decodedDetails":null},"authenticated":true,"userAuthentication":{"authorities":[{"authority":"admin"}],"details":{"client_secret":"admin-web-123","grant_type":"password","client_id":"admin-web","username":"admin"},"authenticated":true,"principal":{"password":null,"username":"admin","authorities":[{"authority":"admin"}],"accountNonExpired":true,"accountNonLocked":true,"credentialsNonExpired":true,"enabled":true},"credentials":null,"name":"admin"},"oauth2Request":{"clientId":"admin-web","scope":["all"],"requestParameters":{"grant_type":"password","client_id":"admin-web","username":"admin"},"resourceIds":[],"authorities":[],"approved":true,"refresh":false,"redirectUri":null,"responseTypes":[],"extensions":{},"grantType":"password","refreshTokenRequest":null}………</span><br></pre></td></tr></tbody></table></figure><p>最后，这里鉴权的高可用通过k8s的service，进行默认的轮询方式的访问鉴权中心，鉴权中心如果鉴权时不管使用redis还是jwt，来管理token，都是可以的。</p><br><br><p><span class="suffix" style="display: none;"></span></p><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码:</p><pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px;"><code class="hljs" style="overflow-x: auto; padding: 16px; color: #abb2bf; background: #282c34; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;">https://gitee.com/damon_one/spring-cloud-k8s</code></pre><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">交个朋友之猿天地</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://xiao8.github.io" style="text-decoration: none" title="">交个朋友之猿天地 | 微服务 | 容器化 | 自动化</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：交个朋友之猿天地"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="后端" scheme="http://xiao8.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://xiao8.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Jupyter Notebook 的使用</title>
    <link href="http://xiao8.github.io/2021/07/12/jupyter/"/>
    <id>http://xiao8.github.io/2021/07/12/jupyter/</id>
    <published>2021-07-12T09:45:47.000Z</published>
    <updated>2021-12-06T03:02:19.403Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="深度学习编程常用工具"><a href="#深度学习编程常用工具" class="headerlink" title="深度学习编程常用工具"></a>深度学习编程常用工具</h2><p>我们先来看 4 个常用的编程工具：Sublime Text、Vim、Jupyter。虽然我介绍的是 Jupyter，但并不是要求你必须使用它，你也可以根据自己的喜好自由选择。</p><h3 id="Sublime-Text"><a href="#Sublime-Text" class="headerlink" title="Sublime Text"></a>Sublime Text</h3><p>第一个是 Sublime Text，它是一个非常轻量且强大的文本编辑工具，内置了很多快捷的功能，同时还支持很丰富的插件功能，对我们来说非常方便。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfeb7e6743984c8797599c30e4b39c3d~tplv-k3u1fbpfcp-watermark.image" alt="1625538727(1).jpg"></p><p>如上图所示，它可以自动为项目中的类、方法和函数生成索引，我们让我们可以跟踪代码。可以通过它的 goto anything 功能，根据一些关键字查找到项目中的对应的代码行。</p><h3 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h3><p>第二个是 Vim，它是 Linux 系统中的文本编辑工具，方便快捷且强大，我们在项目中经常会使用到。</p><p>在我们的项目中，经常需要登录到服务器上进行开发，而服务器一般都是 Linux 系统，不会有 Sublime Text 与 Pycharm，所以我们可以直接用 Vim 打开代码进行编辑。对于没有接触过 Linux 或者是一直使用 IDE 进行编程开发的同学，一开始可能觉得不是很方便，但 Vim 的快捷键十分丰富，对于 Shell 与 Python 的开发来说非常便捷。</p><p>Vim 的缺点正如刚才所说，有一点点门槛，需要你去学习它的使用方法。只要你学会了，我保证你将对它爱不释手。</p><h3 id="Jupyter-Notebook-amp-Lab"><a href="#Jupyter-Notebook-amp-Lab" class="headerlink" title="Jupyter Notebook &amp; Lab"></a>Jupyter Notebook &amp; Lab</h3><p>最后一个是今天要介绍的 Jupyter Notebook 了，它是一个开源的 Web 应用，能够让你创建、分享包含可执行代码、可视化结构和文字说明的文档。</p><p>Jupyter Notebook 的应用非常广泛，它可以用在数据清理与转换、数字模拟、统计模型、数据可视化、机器学习等方面。</p><p>Jupyter Notebooks 非常活跃于深度学习领域。在项目的实验测试阶段，它相比于用 py 文件来直接编程还是方便一些。在项目结束之后如果要写项目报告，用 Jupyter 也比较合适。</p><p>简单介绍之后，我们接下来就从 Jupyter 的功能、Jupyter 的安装与启动与 Jupyter Lab 的操作这 3 个方面学习 Jupyter。</p><h2 id="Jupyter-Notebook-amp-Lab-的功能"><a href="#Jupyter-Notebook-amp-Lab-的功能" class="headerlink" title="Jupyter Notebook &amp; Lab 的功能"></a>Jupyter Notebook &amp; Lab 的功能</h2><p>Jupyter 主要有以下 3 点的作用：执行代码、数据可视化以及使用 Markdown 功能写报告。</p><ul><li><strong>执行代码</strong>。一般是 Python 程序，也可以添加新的编程语言。</li><li><strong>数据可视化</strong>。设想一下，我们经常在 Linux 环境编程开发，如果需要对数据可视化该怎么办呢？是不是只能把图片保存下来，然后下载到本地进行查看？使用 Jupyter Notebook 就不用多此一举，我们可以直接在页面中查看。如下图所示：</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6209a42f5ae4c3196ca5277525edc86~tplv-k3u1fbpfcp-watermark.image" alt="图片.png"></p><ul><li><strong>使用 Markdown 功能写文档</strong>，或者制作 PPT。这些文档中还包含代码以及代码执行后的结果，非常有助于你书写项目报告。</li></ul><h2 id="Jupyter-Notebook-amp-Lab-的安装与启动"><a href="#Jupyter-Notebook-amp-Lab-的安装与启动" class="headerlink" title="Jupyter Notebook &amp; Lab 的安装与启动"></a>Jupyter Notebook &amp; Lab 的安装与启动</h2><p>了解了 Jupyter 的功能之后，我们来看看具体要如何进行安装与启动。这一节我介绍了 3 种安装和启动的方式，分别是 Anaconda、Docker 和 pip。</p><h3 id="使用-Anaconda-安装与启动"><a href="#使用-Anaconda-安装与启动" class="headerlink" title="使用 Anaconda 安装与启动"></a>使用 Anaconda 安装与启动</h3><p>我们先来看如何使用 Anaconda 来安装与启动。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>最简单的方法是通过安装 Anaconda 来使用 Jupyter Notebook &amp; Lab。Anaconda 已自动安装了 Jupter Notebook 及其他工具，还有 Python 中超过 180 个科学包及其依赖项。你可以通过 Anaconda 的官方网站得到 Anaconda 的下载工具。</p><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>这里我会分 MacOS 系统和 Win 环境来讲解。</p><p>（1）MacOS 系统</p><p>安装完 Anaconda 之后，打开终端后系统会默认进入 base 环境。</p><p>在命令行最前面有个**(base)**的标志则表示代码进入 base 环境了，如果没有就需要通过下面的命令激活 base 环境：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">conda activate base<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 base 环境下执行下面的命令，会自动进入 Jupyte Notebook 的开发环境。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">jupyter notebook<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行下面的命令，则会自动进入到 Jupyter Lab 的开发环境。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">jupyter lab<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（2）Win 环境</p><p>Windows 环境中的启动方式与 MacOS 基本一样。</p><p>当你想通过命令 Jupyter Notebook 或 Jupyter Lab 启动时，你需要在 Anaconda Prompt 中执行。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b07bc943d80b4a5e9f11f41403a0973c~tplv-k3u1fbpfcp-watermark.image" alt="图片.png"></p><p>通过 Anaconda Navigator 启动的方式与 MacOS 一样。</p><h3 id="使用-Docker"><a href="#使用-Docker" class="headerlink" title="使用 Docker"></a>使用 Docker</h3><p>通过 Docker 使用 Jupyter 也非常简单，连安装都不需要，但前提是你要有 Docker 相关的知识。</p><h3 id="使用-pip-安装与启动"><a href="#使用-pip-安装与启动" class="headerlink" title="使用 pip 安装与启动"></a>使用 pip 安装与启动</h3><p>了解完 Anaconda 和 Docker 的安装与启动方式后，我们最后来看 pip 是如何安装和启动的。</p><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>通过 pip 安装 Jupyter Notebook：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">pip install Jupyter<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过 pip 安装 Jupyter Lab：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">pip install Jupyterlab<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h4><p>安装完成后，直接在终端执行 Jupyter Notebok 或 Jupyter Lab 命令启动。</p><p>不管在 MacOS 系统还是在 Windows 系统，通过以上任意一种方式成功启动后，浏览器都会自动打开 Jupyter Notebook 或 Jupyter Lab 的开发环境:</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec1235e0b1004723990c343b6956291d~tplv-k3u1fbpfcp-watermark.image" alt="bd2c4bd7559b0eba46fee22e41eda79.png"></p><h2 id="Jupyter-Lab-的操作"><a href="#Jupyter-Lab-的操作" class="headerlink" title="Jupyter Lab 的操作"></a>Jupyter Lab 的操作</h2><p>Jupyter Lab 是 Jupyter Notebook 的下一代产品，在使用方式上更为灵活、便捷。</p><p>我们在命令行或者 Anaconda Navigator 中启动 Jupyter Lab 之后，浏览器会自动打开如下所示的 Jupyter Lab 界面：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3718f1af4004d68bc385602819b4927~tplv-k3u1fbpfcp-watermark.image" alt="1625538963(1).jpg"></p><p>最左侧显示的是你启动时所在的目录，右侧是你可以使用的一些开发工具。</p><h3 id="Notebook"><a href="#Notebook" class="headerlink" title="Notebook"></a>Notebook</h3><p>点击 Notebook 下面的“Python 3”的图标之后，就会自动新建一个 Notebook。</p><ul><li><p>Jypter Lab 与 Jupyter Notebook 中都会用到这个叫作 Notebook 的编辑工具。</p></li><li><p>Jupyter Lab 与 Jupyter Notebook 不同的地方是 IDE 的界面以及操作方式，这里讲解用的是 Jupyter Lab 的操作。</p></li></ul><p>一个 Notebook 的编辑界面主要由 4 个部分组成：菜单栏、工具栏、单元格（Cell）以及内核。如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/729b1c5e8545477da2a0dd662ac3b51a~tplv-k3u1fbpfcp-watermark.image" alt="图片.png"></p><p>菜单栏与工具栏这里就不详细介绍了。我们先来看单元格（Cell），然后再介绍内核。</p><h4 id="单元格（Cell）"><a href="#单元格（Cell）" class="headerlink" title="单元格（Cell）"></a>单元格（Cell）</h4><p>单元格是我们 Notebook 的主要内容，这里我会介绍两种单元格。</p><ul><li><p>Code 单元格：包含可以在内核运行的代码，并且在单元格下方输出运行结果。</p></li><li><p>Markdown 单元格：包含运用 Markdown 的文档，常用于文档的说明，也是可以运行的单元格。</p></li></ul><p>从 Code 单元格切换到 Markdown 单元格的切换的快捷键是 m；从 Markdown 单元格切换到 Code 单元格的切换的快捷键是 y。</p><p><strong>切换之前需要先按 Esc，从单元格的编辑状态中退出。</strong></p><p>在工具栏中也可以切换，但是还是快捷键方便些。工具栏的位置在下图中红框的位置：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/185623dcc6b54a139822fa5096dab47a~tplv-k3u1fbpfcp-watermark.image" alt="图片.png"></p><p>我们看一个例子。我编辑了下面的 Notebook。第一行是 1 个 Markdown 单元格，是 1 个一级标题，第二行是 1 个 Python 的代码。两行代码都是未运行状态。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1443a77e3a304bdf90f86f0e1bbd663a~tplv-k3u1fbpfcp-watermark.image" alt="图片.png"><br>你注意到左边那个蓝色的竖条了吗？它代表我们所在的单元格。</p><p>我们在编辑这个单元格的时候，左边是绿色的竖条。如果我们按 Esc 退出单元格，它就会变为蓝色。</p><p>退出单元格后，我们可以通过上下键移动选中的单元格。我们移动到第一行，然后开始运行这两个单元格。</p><p>运行单独一个单元格的快捷键 Ctrl+Enter，运行选中单元格并切换到下一个单元格的快捷键是 Shift + Enter。运行结果如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a555c931a70447389c7c75ee2d98506~tplv-k3u1fbpfcp-watermark.image" alt="图片.png"></p><p>Markdown 没有左边的“[]”标签，通过这一点你可以区分 Code 单元格与 Markdown 单元格。</p><p>“[]”中的数字代表单元格被执行的顺序，例子中“[1]”代表第一个被执行的单元格。</p><p>以上就是单元格的内容了。我们接下来看看，单元格中的一些快捷键的使用。</p><p><strong>（1）快捷键</strong></p><p>如果你是用 Jupyter 进行开发，掌握单元格的快捷键能让你的开发速度变得更快，下面我列举了几个常用的快捷键：</p><ul><li>执行单元格 Ctrl+Enter 或 Shift+Enter；</li><li>a 在单元格上方插入新的单元格；</li><li>b 在单元格下方插入新的单元格；</li><li>x 删除单元格；</li><li>z 撤销删除的单元格。</li></ul><p><strong>（2）Magic 命令</strong></p><p>Jupyter Notebook 的前身是 IPython Notebook，所以 Jupyter 也支持 IPython 的 Magic 命令。IPython 是一个比 Python 自带的 Shell 更加灵活方便的 Shell，它主要活跃于数据科学领域。</p><p>Magic 命令分两种：</p><ul><li><p>Line Magics 命令：在命令前面加%，表示只在本行有效</p></li><li><p>Cell Magics 命令：在命令前面加%%，表示在整个 Cell 单元有效。</p></li></ul><p>下面我介绍几个常用的 Magic 命令。</p><ul><li>%lsmagic：用来查看可以使用的 Magic 命令。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b547cab1c4740309b6acaa84e80dbb4~tplv-k3u1fbpfcp-watermark.image" alt="图片.png"></p><ul><li><p>%matplotlib inline：可以在单元格下面直接打印出 matplotlib 的图标，通常要在 matplotlib 模块引入之前使用；使用这个 Magic 命令之后，可以不用 plt.show()。</p></li><li><p>%pwd：查看当前的文件路径。</p></li><li><p>%%writefile：写文件，%%writefile 后面紧跟着文件名，然后下面写文件的内容。</p></li><li><p>%run： 运行一个文件，%run 后面跟着要运行的文件。</p></li><li><p>%load：加载文件。使用%load + 文件名可以把指定的文件加载到单元格内。请看下面的例子，我们要把 temp.py 加载到单元格里，首先是执行前，</p></li></ul><p><strong>（3）Markdown 命令</strong></p><p>了解了 Magic 命令后，我们再来看 Markdown 命令。Markdown 是一种在 Markdown 单元中用于格式化文本的语言，常用于 Notebook 的文档说明，我们列举了几个常用的命令。</p><ul><li>标题：通过井号的数目可以决定标题的大小。</li></ul><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token title important"><span class="token punctuation">#</span> 一级标题：</span><span class="token title important"><span class="token punctuation">##</span> 二级标题：</span><span class="token title important"><span class="token punctuation">###</span> 三级标题：</span><span class="token title important"><span class="token punctuation">####</span> 四级标题：</span><span class="token title important"><span class="token punctuation">#####</span> 五级标题：</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>列表：分为无序列表与有序列表。</li></ul><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token title important"><span class="token punctuation">##</span> 无序列表</span><span class="token list punctuation">-</span> 项目 1<span class="token list punctuation">-</span> 项目 2<span class="token title important"><span class="token punctuation">##</span> 有序列表</span><span class="token list punctuation">1.</span> 项目 1 (1. 与项目 1 之间有一个空格)<span class="token list punctuation">2.</span> 项目 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>字体：可以通过”*”或者_的数目控制强调的内容，即斜体、加粗以及粗斜体。具体的请看下面的例子。<pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token italic"><span class="token punctuation">*</span><span class="token content">斜体</span><span class="token punctuation">*</span></span><span class="token bold"><span class="token punctuation">**</span><span class="token content">加粗</span><span class="token punctuation">**</span></span><span class="token bold"><span class="token punctuation">**</span><span class="token content"><span class="token italic"><span class="token punctuation">*</span><span class="token content">粗斜体</span><span class="token punctuation">*</span></span></span><span class="token punctuation">**</span></span>或者<span class="token italic"><span class="token punctuation">_</span><span class="token content">斜体</span><span class="token punctuation">_</span></span><span class="token bold"><span class="token punctuation">__</span><span class="token content">加粗</span><span class="token punctuation">__</span></span><span class="token bold"><span class="token punctuation">__</span><span class="token content"><span class="token italic"><span class="token punctuation">_</span><span class="token content">粗斜体</span><span class="token punctuation">_</span></span></span><span class="token punctuation">__</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>（4）调用系统命令</strong></p><p>最后，在 Notebook 中还可以调用所在操作系统的命令，只需要在命令前加一个“!”就可以了。例如，在 Linux 系统中查看当前路径：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">!pwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="后端" scheme="http://xiao8.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Jupyter" scheme="http://xiao8.github.io/tags/Jupyter/"/>
    
  </entry>
  
  <entry>
    <title>Service Mesh 是下一代微服务架构</title>
    <link href="http://xiao8.github.io/2021/03/30/ServiceMesh-01/"/>
    <id>http://xiao8.github.io/2021/03/30/ServiceMesh-01/</id>
    <published>2021-03-30T07:09:35.000Z</published>
    <updated>2022-07-28T07:07:25.369Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Service-Mesh-背后的诉求"><a href="#Service-Mesh-背后的诉求" class="headerlink" title="Service Mesh 背后的诉求"></a>Service Mesh 背后的诉求</h2><p>一种技术的出现必然是有各种推动的因素，Service Mesh 也一样，它的出现就得益于微服务架构的发展。那 Service Mesh 出现时，其背后的诉求是什么呢？</p><h3 id="1-微服务架构的复杂性"><a href="#1-微服务架构的复杂性" class="headerlink" title="1. 微服务架构的复杂性"></a>1. 微服务架构的复杂性</h3><p>在微服务架构中，应用系统往往被拆分成很多个微服务（可以多达成百上千），数量庞大的微服务实例使得服务治理具有一定的挑战，比如说常见的服务注册、服务发现、服务实例的负载均衡，以及为了保护服务器实现熔断、重试等基础功能。除此之外，应用程序中还加上了大量的非功能性代码。</p><p>归根结底，在微服务架构中，微服务组件复杂、上手门槛比较高成了痛点问题。业务开发团队需要一定的学习周期才能上手微服务架构的开发，而人力资源的昂贵以及人员的流动性使得开发成本变高。业务开发团队更加擅长的是某一具体领域的业务，而不是技术的深度。应用系统的核心价值在于实现相应的业务，所以对于业务开发人员来说，微服务仅仅是手段，不是最终的目标。我们需要对业务开发人员“屏蔽”微服务的基础组件，使得微服务之间的通信对于业务开发人员透明。</p><p>为应对这个问题，有一些实践是利用 API 网关接收请求，网关作为代理处理外部服务的请求，并提供服务注册与发现、负载均衡、日志监控、容错等功能。然而，这种方案也存在不足，比如网关的单点故障、系统架构变得异常庞大；从功能来看，API 网关主要是面向用户，也就是说它可以解决从用户到各个后端服务的流量问题，至于其他问题，它可能就无能为力了。而我们需要的是一个完整的贯穿整个请求周期的方案，或者至少是一些能够与 API 网关互补的方案和工具。</p><h3 id="2-微服务本身的挑战"><a href="#2-微服务本身的挑战" class="headerlink" title="2. 微服务本身的挑战"></a>2. 微服务本身的挑战</h3><p>微服务还有其自身引入的复杂度，有比学习微服务框架更艰巨的挑战，如微服务的划分、设计良好的声明式 API、单体旧应用的迁移，还涉及跨多个服务的数据一致性，这都会令大部分团队疲于应付。</p><p>除此之外，版本兼容性也是一个挑战。微服务框架很难一开始就完美无缺，在现实的软件工程中一般不存在这样完美无缺的框架，功能会分为多个里程碑迭代，发布之后就会有补丁修复……没有任何问题，这只是一种理想状态。业务服务中引入微服务的基础组件，这样业务服务的代码和微服务的 SDK 强耦合在一起，导致业务升级和微服务 SDK 的升级强绑定在了一起。如果客户端 SDK 和服务器端版本不一致，那就得谨慎对待客户端与服务端的兼容性问题。版本兼容性的处理非常复杂，特别是在服务端和客户端数量庞大的情况下，每对客户端和服务端的版本都有可能不同，这对于兼容性测试也会造成很大的压力。同时，对于异构的系统，还需要开发多语言的 SDK，维护成本很高。</p><h3 id="3-本质"><a href="#3-本质" class="headerlink" title="3. 本质"></a>3. 本质</h3><p>接下来我们探讨下业务服务最关心的是什么，比如写一个商品服务，对商品做增删改查的操作，你会发现基础设施、跨语言、兼容性和商品服务本身并没关系，而服务间的通讯才是最需要解决的问题。</p><p>比如，为了保证将客户端发出的业务请求发去一个正确的地方，需要用什么样的负载均衡？要不要做灰度？最终这些解决方案，都是让请求去访问正确的后端服务。整个过程当中，这个请求是从来不发生更改的。</p><p>既然在开发微服务的时候不用特别关心服务的通讯层，那是不是可以把微服务的技术栈向下移呢？</p><p>微服务的早期先驱，如 Netflix、Twitter 等大型互联网公司，它们通过建立内部库的方式处理这些问题，然后提供给所有服务使用。但这种方法的问题在于这些库相对来说是比较“脆弱”的，很难保证它们可以适应所有的技术堆栈选择，且很难把库扩展到成百上千个微服务中。</p><p>为了应对上述的问题，Service Mesh 出现了，&nbsp;Service Mesh 通过独立进程的方式隔离微服务基础组件，对这个独立进程升级、运维要比传统的微服务方式简单得多。</p><h2 id="什么是-Service-Mesh"><a href="#什么是-Service-Mesh" class="headerlink" title="什么是 Service Mesh"></a>什么是 Service Mesh</h2><p>Service Mesh（服务网格），最早在 2016 年 9 月，由开发 Linkerd 的 Buoyant 公司提出。2017 年，Linkerd 加入 CNCF，由 CNCF 托管孵化，Linkerd 是第一个加入 CNCF 的 Service Mesh 项目。Service Mesh 开始变得流行起来，特别是在技术社区，有人指出 Service Mesh 会是下一代的微服务架构基础。</p><p>关于 Service Mesh 的定义，目前比较认同的是 Buoyant 的 CEO William Morgan 在博客中给出的定义：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Service Mesh 是用于处理服务到服务通信的专用基础架构层。云原生有着复杂的服务拓扑，它负责可靠的传递请求。实际上，Service Mesh 通常是作为一组轻量级网络代理实现，这些代理与应用程序代码部署在一起，应用程序无感知。</span><br></pre></td></tr></tbody></table></figure><p>Service Mesh 模式的核心在于将客户端 SDK 剥离，以 Proxy 独立进程运行，目标是将原来存在于 SDK 中的各种能力下沉，为应用减负，以帮助应用云原生化。</p><p>Service Mesh 的第一代产品，如 Linkerd 1 和 Envoy，天然支持虚拟机。随着云原生的崛起，到了 Istio 和 Linkerd 2 ，不支持虚拟机。相比虚拟机，Kubernetes 提供了太多便利。 绝大部分Service Mesh 的实现都支持 Kubernetes，有些实现甚至只支持 Kubernetes。就这样，Service Mesh 逐步发展为一个独立的基础设施层。</p><p>在云原生架构下，应用系统可能由数百个微服务组成，微服务一般又是多实例部署，并且每一个实例都可能处于不断变化的状态，因为它们是由 Kubernetes 之类的资源调度系统动态调度。 Kubernetes 中的 Service Mesh 实现模式被命名为 Sidecar（边车模式，因为类似连接到摩托车的边车）。</p><p>在模式库中，Sidecar 模式的定义是：将应用程序的组件部署到单独的进程或容器中以提供隔离和封装。这种模式还可以使应用程序由异构组件和技术组成。</p><p>在 Sidecar 模式中，“边车”与父应用程序（即业务服务）是两个独立的进程，二者生命周期相同，同时被创建和退出。“边车”附加到业务服务，并为应用提供支持功能。</p><p>业务所有的流量都转发到 Service Mesh 的代理服务 Sidecar 中，Sidecar 承担了微服务框架基础的功能，包括服务注册与发现、负载均衡、熔断限流、认证鉴权、日志、监控和缓存加速等。不同的是，Service Mesh 强调的是通过独立进程的代理方式。总体来说，Service Mesh 帮助应用程序在复杂的软件架构和网络中建立稳定的通信机制。</p><h2 id="Service-Mesh-的开源组件"><a href="#Service-Mesh-的开源组件" class="headerlink" title="Service Mesh 的开源组件"></a>Service Mesh 的开源组件</h2><p>近几年 Service Mesh 社区比较活跃，其对应的开源组件也很丰富，从最早的 Linkerd 到当前火热的 Istio、Envoy 等组件，下面我们就来重点介绍下这三个开源组件。</p><h3 id="1-Istio"><a href="#1-Istio" class="headerlink" title="1. Istio"></a>1. Istio</h3><p>Istio 由 Google、IBM 和 Lyft 合作开源，所以 Istio 自诞生之日起就备受瞩目。在 Istio 中，直接使用了 Lyft 公司的 Envoy 作为 Sidecar。2017 年 5 月 Istio 发布了 0.1 版本，现在已经发展到 1.9 版本。Istio 是 Service Mesh 的第二代产品，在刚开始发布时还曾计划提供对非 Kubernetes 的支持，发展到现在基本只支持 Kubernetes 上的使用，实质性取消了对虚拟机的支持。</p><p>Istio 功能十分丰富，包括：</p><p>流量管理：Istio 的基本功能，Istio 的流量路由规则使得你可以轻松控制服务之间的流量和 API 调用。</p><p>策略控制：应用策略并确保其得到执行，并且资源在消费者之间公平分配。</p><p>可观测性：通过自动链路追踪、监控和服务的日志，可以全面了解受监视服务如何与其他服务以及 Istio 组件本身进行交互。</p><p>安全认证：通过托管的身份验证，授权和服务之间通信的加密自动保护服务。Istio Security 提供了全面的安全解决方案来解决这些问题。</p><p>Istio 针对现有的服务网络，提供了一种简单的方式将连接、安全、控制和观测的模块，与应用程序或服务隔离开来，从而使开发人员可以将更多的精力放在核心的业务逻辑上。另外，Istio 直接基于成熟的 Envoy 代理进行构建，控制面组件则都是使用 Go 编写，在不侵入应用程序代码的前提下实现可视性与控制能力。总之，Istio 的设计理念是非常新颖前卫的。</p><h3 id="2-Linkerd"><a href="#2-Linkerd" class="headerlink" title="2. Linkerd"></a>2. Linkerd</h3><p>2016 年 1 月，前 Twitter 工程师 William Morgan 和 Oliver Gould 组建了一个名为 Buoyant 的公司，同时在 GitHub 上发布了 Linkerd 0.0.7 版本。Linkerd 由 Buoyant 推出，使用 Scala 语言实现，是业界第一个 Service Mesh。2017 年 1 月，Linkerd 加入 CNCF； 4 月，发布了 1.0 版本。</p><p>Linkerd 的架构由两部分组成：数据平面和控制平面。其中，数据平面由轻量级代理组成，它们作为 Sidecar 容器与服务代码的每个实例一起部署；控制平面是一组在专用 Kubernetes 命名空间中运行的服务（默认情况下）。这些服务承担聚合遥测数据、提供面向用户的 API、向数据平面代理提供控制数据等功能，它们共同驱动着数据平面的行为。</p><p>Linkerd 作为 Service Mesh 的先驱开源组件，在生产环境得到了大规模使用。Linkerd 2 的定位是 Kubernetes 的 Service Mesh，其提供了运行时调试、可观察性、可靠性和安全性，使得运行服务变得更容易、更安全，而无须更改代码。但是随着 Istio 的诞生，前景并不是特别乐观。</p><h3 id="3-Envoy"><a href="#3-Envoy" class="headerlink" title="3. Envoy"></a>3. Envoy</h3><p>2016 年 9 月，Lyft 公司开源 Envoy ，并在 GitHub 上发布了 1.0.0 版本。Envoy 由 C++ 实现，性能和资源消耗上表现优秀。2017 年 9 月，Envoy 加入 CNCF，成为继 Linkerd 之后的第二个 Service Mesh 项目。Envoy 发展平稳，被 Istio 收编之后，Envoy 将自身定义为数据平面，并希望使用者可以通过控制平面来为 Envoy 提供动态配置。Envoy 用于云原生应用，为应用服务提供高性能分布式代理，以及作为大规模微服务架构的 Service Mesh 通信总线和通用数据平面。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://gitee.com/damon_one/spring-cloud-k8s</span><br><span class="line">https://gitee.com/damon_one/spring-cloud-oauth2</span><br><span class="line">https://gitee.com/damon_one/Springcloud-Learning-Dalston</span><br></pre></td></tr></tbody></table></figure><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">交个朋友之猿天地</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://xiao8.github.io" style="text-decoration: none" title="">交个朋友之猿天地 | 微服务 | 容器化 | 自动化</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：交个朋友之猿天地"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="后端" scheme="http://xiao8.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="后端" scheme="http://xiao8.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>什么是服务网格（Service Mesh）</title>
    <link href="http://xiao8.github.io/2021/03/30/Service-Mesh/"/>
    <id>http://xiao8.github.io/2021/03/30/Service-Mesh/</id>
    <published>2021-03-30T06:41:28.000Z</published>
    <updated>2022-07-28T07:07:23.631Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>服务网格（Service Mesh）是随着 Kubernetes 和微服务架构的流行而出现的新技术，它的目的是解决微服务架构的服务之间相互调用时可能存在的各种问题。微服务架构的服务之间采用进程间的通讯方式进行交互，比如 REST 或 gRPC 等。在第 01 课时介绍微服务架构的时候，我提到过影响微服务架构复杂度的一个重要因素就是微服务之间的相互调用，这使得应用需要对服务调用时产生的错误进行处理。比如，当调用一个服务出现超时错误时，应该进行重试；如果对某个服务的调用在一段时间内频繁出错，说明该服务可能已经崩溃或是负载过大，没有必要再继续进行尝试下去了。</p><p>除了错误处理之外，我们还可能需要对服务之间的调用添加一些策略，比如限制服务被调用的速率，或是添加安全相关的访问控制规则等。这些需求从服务之间的调用而来，并且所有微服务架构的应用都有同样的需求，这些横切的需求，应该由平台或工具来处理，而不需要应用来实现，应用要做的只是提供相关的配置即可。</p><p>在 Kubernetes 出现之前，微服务架构已经在很多企业内部得到了应用。同样的，在服务网格之前也有相似的工具来解决服务调用相关的问题，比如 Netflix OSS 栈中的 Hystrix，但服务网格技术是在已有工具上的升级，它提供了一个更完整的解决方案。</p><p>严格说来，服务网格并不直接依赖 Kubernetes，但绝大部分服务网格实现都支持 Kubernetes，有些实现甚至只支持 Kubernetes。这是因为 Kubernetes 平台提供的功能可以简化服务网格的使用。下面我来为你介绍 Kubernetes 中的边车模式（Sidecar）。</p><h3 id="边车模式"><a href="#边车模式" class="headerlink" title="边车模式"></a>边车模式</h3><p>在 Kubernetes 中，Pod 中的容器通常是紧密耦合的，它们共同完成应用的功能。如果需要实现横切功能，则需要在 Pod 中添加与应用无关的容器，这是因为横切功能的实现离不开对应用使用的存储和网络的访问，而 Pod 中的容器之间共享存储和网络。当我们把横切服务的容器添加到 Pod 中后，Pod中就多了与应用无关的容器，这种部署模式称为边车模式，这些容器被称为边车容器，下图是现实世界中的边车。</p><p>日志收集是边车模式的一个常见应用，它利用了 Pod 中容器共享存储的特性：应用容器往某个持久卷中写入日志，而日志收集工具的边车容器则监控同一个持久卷中的文件来读取日志。</p><p>边车容器在服务网格实现中至关重要。服务网格实现会在每个 Pod 上增加一个新的边车容器来作为其中应用服务的代理，这个容器的代理程序会作为外部调用者和实际服务提供者之间的桥梁。</p><p>如下图所示，Pod 某个端口上的请求，首先会被服务代理处理，然后再转发给实际的应用服务；同样的，应用服务对外的请求，也会先被服务代理处理，然后再转发给实际的接收者。代理边车容器的出现，为解决服务调用相关的问题提供了一种新的方案：服务调用的自动重试和断路器模式的实现，都可以由服务代理来完成，从而简化应用服务的实现。</p><img src="https://static001.geekbang.org/infoq/25/25238dd65ebd30ae0442e82c0f60810c.png" style="display: block; margin: 0 auto; max-width: 100%;"><p>如果仅从最基本的实现方式上来说，服务网格技术并不复杂。打个比方，如果一个 Pod 提供某个应用服务，只需要在该 Pod 中部署一个服务代理的边车容器，由该代理来处理应用容器发送和接收的数据，就实现了服务网格。</p><p>但是，服务网格实际上的解决方案非常复杂，我会在下面进行具体的介绍。</p><p>值得一提的是，边车模式并不是服务代理的唯一部署方式。有些服务网格实现可以在Kubernetes的节点上部署服务代理来处理该节点上的全部请求。</p><h3 id="服务代理"><a href="#服务代理" class="headerlink" title="服务代理"></a>服务代理</h3><p>服务代理是服务网格技术实现的核心，可以说，服务代理决定了服务网格能力的上限。从作用上来说，服务代理与我们所熟悉的 Nginx 和 HAProxy 这类代理并没有太大区别。实际上， Nginx 和 HAProxy 同样可以作为服务代理来使用，但服务网格通常使用专门为服务间调用开发的服务代理实现。在下图所示的 OSI 七层模型中，服务代理一般工作在第 3/4 层和第 7 层。</p><img src="https://static001.geekbang.org/infoq/d7/d78ab20067d165fed51ae7c025c13c29.png" style="display: block; margin: 0 auto; max-width: 100%;"><p>下表列出了常见的服务代理，其中 Envoy、Traefix 和 Linkerd 2 都是新出现的服务代理实现。</p><img src="https://static001.geekbang.org/infoq/a0/a052b50d05a906b856f4953bf6bb422a.png" style="display: block; margin: 0 auto; max-width: 100%;"><p>服务发出和接收的所有调用都需要经过服务代理。服务代理的功能都与服务之间的调用相关，其主要方面如下表所示。&nbsp;</p><img src="https://static001.geekbang.org/infoq/58/58cb1d35b7a1b2debc92bd557a8edf12.png" style="display: block; margin: 0 auto; max-width: 100%;"><p>代理可以在请求层上工作。当服务 A 调用服务 B 时，服务 A 的代理可以使用负载均衡来动态选择实际调用的服务 B 实例，如果对服务 B 的调用失败，并且该调用是幂等的，则代理可以自动进行重试。服务 A 的代理还可以记录与调用相关的指标数据，服务 B 的代理可以根据访问控制的策略决定是否允许该请求，如果服务 B 当前所接收的请求过多，那么它的代理可以拒绝其中某些请求。</p><p>代理同样可以工作在连接层，服务 A 和服务 B 的代理之间可以建立 TLS 连接，并验证对方的身份。</p><p>由于服务代理需要处理服务所有接收和发送的请求，这对服务代理的性能要求很高，不能增加过长的延迟，这也是 Envoy 等服务代理流行的原因，这些新开发的服务代理对服务之间的调用进行了优化。除了性能之外，服务代理只占用很少的 CPU 和内存资源，这是因为每个服务实例的 Pod 上都可能运行着一个服务代理的容器，当服务数量增加时，服务代理自身的资源开销也会增加。</p><h3 id="服务网格"><a href="#服务网格" class="headerlink" title="服务网格"></a>服务网格</h3><p>服务网格技术起源于 Linkerd 项目，从架构上来说，服务网格的实现很简单，它由服务代理和管理进程组成。服务代理称为服务网格的数据平面（Data Plane），负责拦截服务之间的调用并进行处理；管理进程称为服务网格的控制平面（Control Plane），负责协调代理并提供 API 来管理和监控服务网格。服务网格的能力由这两个平面的能力共同决定。</p><p>下图给出了服务网格的基本架构:</p><img src="https://static001.geekbang.org/infoq/2d/2db5eba7b3d8a3e057accfd1929e24bd.png" style="display: block; margin: 0 auto; max-width: 100%;"><p>服务网格在数据平面的处理能力取决于所使用的服务代理，而服务网格实现通常使用已有的服务代理，因此它们在数据平面方面的能力差别并不大。服务网格实现的价值更多来源于它所提供的控制平面，比如，服务网格实现是否提供了 API 来更新配置，是否提供了图形化界面来查看服务状态，在 Kubernetes 上，是否可以使用自定义资源定义（Custom Resource Definition，CRD）来进行声明式配置。</p><p>服务网格技术的优势有以下几个方面:</p><ul><li><p>它与服务实现使用的技术栈无关。服务代理工作在服务调用这个层次上。不论服务采用什么编程语言或框架来实现，服务代理都可以产生作用。Kubernetes 的流行，使得在微服务架构实现中使用多语言开发变得更简单。一个微服务应用的不同服务可以使用完全不同的技术栈来实现，这些服务之间的调用都可以由服务代理来处理。</p></li><li><p>服务网格技术与应用代码是解耦的，这意味着当我们需要对服务调用相关的策略进行调整时，并不需要修改应用的代码。以服务的访问频率为例，当需要控制对某个服务的调用频率时，可以通过服务网格的控制平面提供的 API 直接进行修改，并不需要对应用做任何改动。这种解耦使得服务网格成为应用运行平台所提供的能力之一，进而促成了新的开源项目和商业产品的出现。</p></li><li><p>对于大型项目，可以由专门的团队来负责管理服务网格的配置，进行更新和日常维护；对于小型项目，可以从开源社区选择合适的产品。</p></li></ul><h3 id="服务网格功能"><a href="#服务网格功能" class="headerlink" title="服务网格功能"></a>服务网格功能</h3><p>服务网格所能提供的功能非常多。每个服务网格实现所提供的功能也各有不同。下面我将对服务网格中的重要功能进行介绍。</p><h3 id="自动代理注入"><a href="#自动代理注入" class="headerlink" title="自动代理注入"></a>自动代理注入</h3><p>为了使用服务网格提供的功能，应用服务的 Pod 需要添加服务代理容器，服务网格提供了自动的代理注入机制。在 Kubernetes 上，如果 Pod 或控制器对象中添加了某个特定的注解，则服务网格可以自动在 Pod 中添加服务代理容器并完成相关的配置。</p><p>流量管理</p><p>流量管理指的是管理服务之间的相互调用，由一系列的子功能组成。</p><ol><li>服务发现</li></ol><p>服务发现指的是发现系统中存在的服务及其对应的访问地址，服务网格会在内部维护一个注册表，包含所有发现的服务及其对应的服务端点。</p><ol start="2"><li>负载均衡</li></ol><p>每个服务通常都有多个运行的实例，在进行调用时，需要根据某些策略选择处理请求的实例。负载均衡的算法可以很简单，比如循环制（round robin）；也可以很复杂，比如根据被调用服务的各个实例的负载情况来动态选择。</p><ol start="3"><li>流量控制</li></ol><p>微服务架构的应用强调持续集成和持续部署，应用的每个服务都可以被单独部署。一个常见的需求是在进行更新时，让小部分用户使用新的版本，而大部分用户仍然使用当前的旧版本，这样的更新方式称为金丝雀部署（Canary Deployment）。为了支持这样的更新方式，我们可以同时部署服务的两个版本，并通过服务网格把调用请求分配到两个版本，比如，20% 的请求分配到新版本，剩下 80% 的请求分配到当前版本，经过一段时间的测试之后，再逐步把更多的请求分配到新版本，直到全部请求分配至新版本。</p><ol start="4"><li>超时处理</li></ol><p>服务网格对服务调用添加了超时处理机制。如果调用在设置的时间之后仍然没有返回，则会直接出错，这样就避免了在被调用的服务出现问题时，进行不必要的等待。不过，超时时间也不能设置得过短，否则会有大量相对耗时的调用产生不必要的错误，针对这一点，服务网格提供了基于配置的方式来调整服务的超时时间。</p><ol start="5"><li>重试</li></ol><p>当服务的调用出现错误时，服务网格可以选择进行重试，服务重试看似简单，但要正确的实现并不容易。简单的重试策略，比如固定时间间隔和最大重试次数的做法，很容易产生重试风暴（Retry Storm）。如果某些请求因为服务负载的原因而失败，简单的重试策略会在固定的时间间隔之后，重试全部失败请求，这些请求在重试时又会因为负载过大的原因而再次失败。所造成的结果就是产生大量失败的重试请求，影响整体的性能，有效的重试机制应该避免出现重试风暴。</p><ol start="6"><li>断路器</li></ol><p>断路器（Circuit Breaker）是微服务架构中的一种常见模式。通过断路器，可以在服务的每个实例上设置限制，比如同时允许的最大连接数量，或是调用失败的次数。当设定的限制达到时，断路器会自动断开，禁止对该实例的连接。</p><p>断路器的存在，使得服务调用可以快速失败，而不用尝试连接一个已经失败或过载的实例，所以它的一个重要作用是避免服务的级联失败。如果一个服务出现错误，可能导致它的调用者因为超时而积压很多未处理的请求，进而导致它的调用者也由于负载过大而崩溃，这样的级联效应，有可能导致整个应用的崩溃。使用断路器之后，出现错误的服务实例被自动隔离，不会影响系统中的其他服务。</p><ol start="7"><li>错误注入</li></ol><p>在使用服务网格配置了服务的错误处理策略之后，一个重要的需求是对这些策略进行测试。错误注入指的是往系统中引入错误来测试应用的故障恢复能力，比如，错误注入可以在服务调用时自动添加延迟，或是直接返回错误给调用者。</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>安全相关的功能解决应用的 3 个 A 需求，分别是认证（Authentication）、授权（Authorization）和审计（Audit）。这3个需求的英文名称都以字母A开头，所以称为3个A需求。</p><p>双向 TLS（mutual TLS，mTLS）指的是在服务调用者和被调用者的服务代理之间建立双向 TLS 连接，这个连接意味着客户端和服务器都需要认证对方的身份。通过 TLS 连接可以对通信进行加密，防止中间人攻击。</p><p>用户认证：服务网格应该可以和不同的用户认证服务进行集成，常用的认证方式包括 JWT 令牌认证，以及与 OpenID Connect 提供者进行集成。</p><h3 id="访问策略"><a href="#访问策略" class="headerlink" title="访问策略"></a>访问策略</h3><p>访问策略用来描述服务调用时的策略。</p><ul><li><p>访问速率控制：通过访问速率控制，可以限制服务的调用速度，防止服务因请求过多而崩溃。</p></li><li><p>服务访问控制：服务访问控制用来限制对服务的访问，限制的方式包括禁止服务、黑名单和白名单等。</p></li></ul><h3 id="可观察性"><a href="#可观察性" class="headerlink" title="可观察性"></a>可观察性</h3><p>服务网格可以收集与服务之间通信相关的遥测数据，这些数据使得运维人员可以观察服务的行为，发现服务可能存在的问题，并对服务进行优化。</p><p>性能指标：是指服务网格收集与服务调用相关的性能指标数据，包括延迟、访问量、错误和饱和度。除此之外，服务网格还收集与自身的控制平面相关的数据。</p><p>分布式追踪：可以查看单个请求在服务网格中的处理流程，在微服务架构中，应用接收到的请求可能由多个服务协同处理。在请求延迟过高时，需要查看请求在不同服务之间的调用流程，以及每个服务所带来的延迟。分布式追踪是服务网格提供的工具，可以用来收集相关的调用信息。</p><p>访问日志：用来记录每个服务实例所接收到的请求。</p><h3 id="服务网格产品介绍"><a href="#服务网格产品介绍" class="headerlink" title="服务网格产品介绍"></a>服务网格产品介绍</h3><p>Istio 项目由 Google、IBM 和 Lyft 共同发起。由于有大公司的支持，Istio 项目目前所提供的功能是最完备的，这也意味着 Istio 是最复杂的。Istio 所包含的组件非常多，对应的配置也非常复杂，它的学习曲线很陡，上手并不容易。值得一提的是，Lyft 的 Envoy 团队与 Istio 有很好的合作，这就保证了 Istio 有最好的 Envoy 支持。本专栏将使用 Istio 来作为服务网格的实现。</p><p>Linkerd 是最早的服务网格实现，目前作为 CNCF 的项目来开发。相对 Istio 而言，Linkerd 提供的功能较少，但是也更简单易用。对很多应用来说，Linkerd 所提供的功能已经足够好。</p><p>Maesh 是 Containous 提供的服务网格实现。Maesh 使用 Traefik 作为服务代理。相对于 Istio 和 Linkerd，Maesh 还是一个比较新的项目，需要更多的时间来考察。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://gitee.com/damon_one/spring-cloud-k8s</span><br><span class="line">https://gitee.com/damon_one/spring-cloud-oauth2</span><br><span class="line">https://gitee.com/damon_one/Springcloud-Learning-Dalston</span><br></pre></td></tr></tbody></table></figure><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">交个朋友之猿天地</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://xiao8.github.io" style="text-decoration: none" title="">交个朋友之猿天地 | 微服务 | 容器化 | 自动化</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：交个朋友之猿天地"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="后端" scheme="http://xiao8.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="后端" scheme="http://xiao8.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>云产品年中大优惠</title>
    <link href="http://xiao8.github.io/2021/03/19/popularize-02/"/>
    <id>http://xiao8.github.io/2021/03/19/popularize-02/</id>
    <published>2021-03-19T10:05:26.000Z</published>
    <updated>2022-07-28T07:07:23.680Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">双十一阿里云全网最低：<a class="nav-item-link" target="_blank" href="https://www.aliyun.com/1111/pintuan-share?ptCode=MTc3NDc1NjEyMjkzNTc5N3x8MTE0fDE%3D&amp;userCode=cdnpht6s" style="text-decoration: none" title="InfoQ">立即领取</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">阿里云产品大促：<a class="nav-item-link" target="_blank" href="https://www.aliyun.com/minisite/goods?userCode=cdnpht6s" style="text-decoration: none" title="InfoQ">立即领取</a></p><br><p>专属折扣码：</p><img src="/images/popularize/aliyun.png" style="display: block; margin: 0 auto; max-width: 100%;"><br data-tool="mdnice编辑器"><p>=============================================================================================================================</p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">【腾讯云】11.11 云上盛惠，云产品限时抢购，1核2G云服务器首年88元！<a class="nav-item-link" target="_blank" href="https://curl.qcloud.com/E29fNTk3" style="text-decoration: none" title="InfoQ">立即秒杀</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">【腾讯云】境外1核2G服务器低至2折，半价续费券限量免费领取！<a class="nav-item-link" target="_blank" href="https://curl.qcloud.com/yGyHMrOc" style="text-decoration: none" title="InfoQ">立即秒杀</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">【腾讯云】新客户无门槛领取总价值高达2860元代金券，每种代金券限量500张，先到先得！<a class="nav-item-link" target="_blank" href="https://curl.qcloud.com/ewl6G2Di" style="text-decoration: none" title="InfoQ">立即秒杀</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">【腾讯云】热卖云产品3折起，云服务器、云数据库特惠，服务更稳，速度更快，价格更低！<a class="nav-item-link" target="_blank" href="https://curl.qcloud.com/VuHGCdHM" style="text-decoration: none" title="InfoQ">立即秒杀</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">【腾讯云】腾讯云数据库性能卓越稳定可靠，为您解决数据库运维难题<a class="nav-item-link" target="_blank" href="https://curl.qcloud.com/yZ7iRLoW" style="text-decoration: none" title="InfoQ">立即秒杀</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">【腾讯云】云数据库MySQL基础版1元体验<a class="nav-item-link" target="_blank" href="https://curl.qcloud.com/QYRX2K0A" style="text-decoration: none" title="InfoQ">立即秒杀</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">腾讯云新客专属福利：<a class="nav-item-link" target="_blank" href="https://url.cn/7JAnmBmX" style="text-decoration: none" title="InfoQ">立即秒杀</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">腾讯云十周年大促：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/act/cps/redirect?redirect=33567&amp;cps_key=c140c92d2bde7476bad935dc8ea0ef41&amp;from=activity" style="text-decoration: none" title="InfoQ">立即秒杀</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">腾讯云服务器全球购：<a class="nav-item-link" target="_blank" href="https://url.cn/huMTG8Sc" style="text-decoration: none" title="InfoQ">立即抢购</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">腾讯企业上云特惠活动：<a class="nav-item-link" target="_blank" href="https://url.cn/Vx78pocV" style="text-decoration: none" title="InfoQ">立即抢购</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">腾讯云产品三折：<a class="nav-item-link" target="_blank" href="https://url.cn/vzVRpgHO" style="text-decoration: none" title="InfoQ">立即抢购</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">腾讯服务器X实时音视频 联合大促：<a class="nav-item-link" target="_blank" href="https://url.cn/TpMozc1X" style="text-decoration: none" title="InfoQ">立即抢购</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">腾讯云服务器购买页：<a class="nav-item-link" target="_blank" href="https://url.cn/FH9kStEc" style="text-decoration: none" title="InfoQ">立即抢购</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">腾讯云数据库购买页：<a class="nav-item-link" target="_blank" href="https://url.cn/LyWcueXJ" style="text-decoration: none" title="InfoQ">立即抢购</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">腾讯云新客专属福利：<a class="nav-item-link" target="_blank" href="https://url.cn/RMo8TtHA" style="text-decoration: none" title="InfoQ">立即抢购</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">腾讯云限时秒杀活动：<a class="nav-item-link" target="_blank" href="https://url.cn/Npc7v6ae" style="text-decoration: none" title="InfoQ">立即抢购</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">腾讯云数据库Redis：<a class="nav-item-link" target="_blank" href="https://url.cn/mRkH6Kem" style="text-decoration: none" title="InfoQ">立即抢购</a></p><br><p>=============================================================================================================================</p><br><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">华为云新客专属福利：<a class="nav-item-link" target="_blank" href="https://account.huaweicloud.com/obmgr/invitation/invitation.html?bpName=000000010000000263EE620C0306EC55CA228C7F03DCE166723D7253C2DEA099D34C69DD0FECCE13692F65A613D7DEAFF4BEDA506668EFE88D57BC5DEDD5EA7D1DCC557E55B653A1&amp;inviteCode=00000001000000020DDF706C9C17CC9385769E6F76491B4B2663ACCDCE6E162A8B68F6FBD5ECB0B9&amp;bindType=1&amp;isDefault=1" style="text-decoration: none" title="InfoQ">立即注册</a></p><br><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://gitee.com/damon_one/spring-cloud-k8s</span><br><span class="line">https://gitee.com/damon_one/spring-cloud-oauth2</span><br><span class="line">https://gitee.com/damon_one/Springcloud-Learning-Dalston</span><br></pre></td></tr></tbody></table></figure><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">关于作者</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">  <em style="font-style: italic; color: black;">笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">交个朋友之猿天地</code> 发起人。个人微信 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">MrNull008</code>，个人网站：<a class="nav-item-link" target="_blank" href="http://xiao8.github.io" style="text-decoration: none" title="">交个朋友之猿天地 | 微服务 | 容器化 | 自动化</a>，欢迎來撩。</em></p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：交个朋友之猿天地"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="活动" scheme="http://xiao8.github.io/categories/%E6%B4%BB%E5%8A%A8/"/>
    
    
    <category term="服务器" scheme="http://xiao8.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>备份Kubernetes的5个最佳实践</title>
    <link href="http://xiao8.github.io/2021/02/22/k8s-backup/"/>
    <id>http://xiao8.github.io/2021/02/22/k8s-backup/</id>
    <published>2021-02-22T09:14:29.000Z</published>
    <updated>2022-04-14T08:29:57.857Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>备份应用程序和数据是组织经常需要处理的事情。尽管Kubernetes可以确保应用程序服务的高可用性和可伸缩性，但这些好处并不能有效地保护数据。因此，必须对Kubernetes应用程序进行数据管理和备份，并应将其纳入标准操作流程中。</p><p>但是，备份Kubernetes应用程序需要一种独特的方法，该方法与传统的备份解决方案大不相同。使用Kubernetes，经常会将应用程序部署在集群中跨节点的多个容器中，要备份应用程序以及数据和存储量，你需要考虑所有各种Kubernetes对象和配置数据，还必须适应应用程序快速的开发和部署周期，DevOps的“左移(shift-left)”理念，数据保护，安全要求等。</p><p>鉴于这些独特的要求，备份Kubernetes似乎是一项艰巨的任务，但是你可以采取一些步骤来简化该过程。以下是五个最佳做法：</p><p><strong>1.考虑Kubernetes架构</strong></p><p>一个典型的Kubernetes应用程序由数百个组件组成-Pod，服务(service)，证书，密钥(secret)等等。任何Kubernetes备份解决方案不仅要能够备份和还原数据，而且还要能够备份和还原所有这些组件。至关重要的是，备份解决方案要通过API自动与Kubernetes控制平面进行交互，以便不仅能够发现集群上运行的Kubernetes应用，而且还可以与基础计算，网络和存储基础架构集成。</p><p>存储也是一个重要的考虑因素，必须包含在备份计划中。与应用程序配置数据一样，Kubernetes存储（用于应用程序容器的持久卷）包含需要保护的重要业务数据。</p><p>最后，确定要备份存储的位置。你将其保留在本地s存储还是在云中？灵活性和易用性将成为任何数据备份存储的重要特征。</p><p><strong>2.制定恢复计划</strong></p><p>由于Kubernetes应用程序的分布式架构，还原数据需要很多步骤。例如，你需要验证集群依赖关系，创建新的Kubernetes视图的替代数据，并确定在何处启动恢复。然后，你需要标识备份数据源并准备目标存储。一旦计划了这些，就必须更新所有组件以创建新的存储资源。提前创建详细计划可以帮助你引导这个复杂的过程，幸运的是，有些Kubernetes备份解决方案可以自动为你执行此操作，你应该寻找一种支持此功能的解决方案。</p><p>但是可靠的执行计划仅仅是开始。你还应该确保你的备份平台可以将各个步骤转换为相关的Kubernetes API调用。这样可确保恢复功能所需的资源可用，并确保正确部署和配置了云原生应用程序的所有组件。</p><p><strong>3.简化操作</strong></p><p>如果备份需要编码，打包或部署，则开发人员可能会避免使用它们。他们的目标是快速开发和部署应用程序，而复杂的备份过程可能会阻碍其进展。</p><p>因此，备份应由API驱动，并且是无缝衔接的。确保你的解决方案具有针对应用程序而不是其单个组件的自动备份策略，并具有在部署新应用程序时检测和备份新应用程序的能力。最后，确保你的备份解决方案提供了简单的工作流程，并使你的运维团队能够顺畅地遵守任何法规和监控要求。</p><p><strong>4.确保安全</strong></p><p>与任何数据管理功能一样，安全性至关重要。执行Kubernetes备份时，要实施身份和访问管理以及基于角色的访问管理（RBAC）的控件，以确保只有授权的用户和组才能访问备份平台。这使你可以控制谁可以执行任务，例如监视和验证备份，执行还原等，并使你可以向开发人员授予从快照还原应用程序的权限。</p><p>你的解决方案应集成到云提供商的身份验证解决方案中，而无需任何其他工具或API。最后，请确保你的数据已加密-无论是在传输中还是在静止状态。</p><p><strong>5.利用Kubernetes的可移植性</strong></p><p>要利用Kubernetes的可移植性功能，你的备份解决方案应该能够兼容几种发行版和基础架构配置执行还原，并自动转换应用程序的备份版本以在新环境中运行。</p><p>备份解决方案要能够转换所有应用程序依赖项以与新环境兼容，这一点很重要。</p><p><strong>Kubernetes原生备份是你的最佳选择</strong></p><p>无论你的目标是保护Kubernetes应用程序免受数据丢失和损坏，为测试和开发目的备份数据，将应用程序迁移到新环境中，还是支持组织的灾难恢复计划，备份对于高效运维都是必不可少的。</p><p>使用传统解决方案而不是专门为Kubernetes环境设计的解决方案会增加意外数据丢失和配置错误的风险，并且无法提供保护应用程序数据所需的细粒度，可感知的应用程序备份和恢复功能。为了遵守Kubernetes环境中的备份和恢复最佳实践，Kubernetes原生备份解决方案是最佳方法。</p><br data-tool="mdnice编辑器"><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">结束福利</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">开源实战利用 k8s 作微服务的架构设计代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://gitee.com/damon_one/spring-cloud-k8s</span><br><span class="line">https://gitee.com/damon_one/spring-cloud-oauth2</span><br><span class="line">https://gitee.com/damon_one/Springcloud-Learning-Dalston</span><br></pre></td></tr></tbody></table></figure><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎大家 star，多多指教。</p><br data-tool="mdnice编辑器"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：交个朋友之猿天地"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br><br><code style="font-size: 20px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: red">特别声明 <br>原文作者：王延飞 <br>本文原链：http://mtw.so/5GiprA <br>本文转载如有侵权，请联系站长删除，谢谢 <br></code><br>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="后端" scheme="http://xiao8.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="K8s" scheme="http://xiao8.github.io/tags/K8s/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud 与 K8s 在微服务层面的不同</title>
    <link href="http://xiao8.github.io/2021/02/04/spring-cloud-k8s/"/>
    <id>http://xiao8.github.io/2021/02/04/spring-cloud-k8s/</id>
    <published>2021-02-04T02:18:16.000Z</published>
    <updated>2022-07-28T07:07:22.630Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Spring-Boot-1-x-与-2-x-的区别"><a href="#Spring-Boot-1-x-与-2-x-的区别" class="headerlink" title="Spring Boot 1.x 与 2.x 的区别"></a>Spring Boot 1.x 与 2.x 的区别</h3><p>在《<a href="https://xiao8.github.io/2020/07/23/micro-service03/">微服务 Spring Cloud 架构设计</a>》一文中，笔者讲过 Spring Cloud 的架构设计。其实 Spring Boot 在一开始时，运用到的基本就是 Eureka、Config、Zuul、Ribbon、Feign、Hystrix 等。到了 Spring Boot 2.x 的时候，大量的组件开始风云崛起。下面简单列下这两个版本之间的区别如下。</p><p>Spring Boot 1.x 中，session 的超时时间是这样的：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.session.timeout=3600</span><br></pre></td></tr></tbody></table></figure><p>而在 2.x 中：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.servlet.session.timeout=PT120M</span><br></pre></td></tr></tbody></table></figure><p>截然不同的写法，cookie 也是一样的：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  servlet:</span><br><span class="line">    session:</span><br><span class="line">      timeout: PT120M</span><br><span class="line">      cookie:</span><br><span class="line">        name: ORDER-SERVICE-SESSIONID</span><br></pre></td></tr></tbody></table></figure><ul><li>应用的 ContextPath 配置属性改动，跟上面的 session 一样，加上了一个 servlet。</li><li>Spring Boot 2.x 基于 Spring 5，而 Spring Boot 1.x 基于 Spring 4 或较低。</li><li>统一错误处理的基类 AbstarctErrorController 的改动。</li><li>配置文件的中文可以直接读取，不需要转码。</li><li>Acutator 变化很大，默认情况不再启用所有监控，需要定制化编写监控信息，完全需要重写，HealthIndicator,EndPoint 同理。</li><li>从 Spring Boot 2.x 开始，可以与 K8s 结合来实现服务的配置管理、负载均衡等，这是与 1.x 所不同的。</li></ul><h3 id="K8s-的一些资源的介绍"><a href="#K8s-的一些资源的介绍" class="headerlink" title="K8s 的一些资源的介绍"></a>K8s 的一些资源的介绍</h3><p>上面说到 Spring Boot 2.x 可以结合 K8s 来作为微服务的架构设计，那么就先来说下 K8s 的一些组件吧。</p><p>ConfigMap，看到这个名字可以理解：它是用于保存配置信息的键值对，可以用来保存单个属性，也可以保存配置文件。对于一些非敏感的信息，比如应用的配置信息，则可以使用 ConfigMap。</p><p>创建一个 ConfigMap 有多种方式如下。</p><p><strong>1. key-value 字符串创建</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap test-config --from-literal=baseDir=/usr</span><br></pre></td></tr></tbody></table></figure><p>上面的命令创建了一个名为 test-config，拥有一条 key 为 baseDir，value 为 “/usr” 的键值对数据。</p><p><strong>2. 根据 yml 描述文件创建</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: test-config</span><br><span class="line">data:</span><br><span class="line">  baseDir: /usr</span><br></pre></td></tr></tbody></table></figure><p>也可以这样，创建一个 yml 文件，选择不同的环境配置不同的信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">kind: ConfigMap</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: cas-server</span><br><span class="line">data:</span><br><span class="line">  application.yaml: |-</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the World</span><br><span class="line">    ---</span><br><span class="line">    spring:</span><br><span class="line">      profiles: dev</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Dev</span><br><span class="line">    spring:</span><br><span class="line">      profiles: test</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Test</span><br><span class="line">    spring:</span><br><span class="line">      profiles: prod</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Prod</span><br></pre></td></tr></tbody></table></figure><p>注意点：</p><ol><li>ConfigMap 必须在 Pod 使用其之前创建。</li><li>Pod 只能使用同一个命名空间的 ConfigMap。</li></ol><p>当然，还有其他更多用途，具体可以参考官网。</p><p>Service，顾名思义是一个服务，什么样的服务呢？它是定义了一个服务的多种 pod 的逻辑合集以及一种访问 pod 的策略。</p><p>service 的类型有四种：</p><ul><li>ExternalName：创建一个 DNS 别名指向 service name，这样可以防止 service name 发生变化，但需要配合 DNS 插件使用。</li><li>ClusterIP：默认的类型，用于为集群内 Pod 访问时，提供的固定访问地址,默认是自动分配地址,可使用 ClusterIP 关键字指定固定 IP。</li><li>NodePort：基于 ClusterIp，用于为集群外部访问 Service 后面 Pod 提供访问接入端口。</li><li>LoadBalancer：它是基于 NodePort。</li></ul><h3 id="如何使用-K8s-来实现服务注册与发现"><a href="#如何使用-K8s-来实现服务注册与发现" class="headerlink" title="如何使用 K8s 来实现服务注册与发现"></a>如何使用 K8s 来实现服务注册与发现</h3><p>从上面讲的 Service，我们可以看到一种场景：所有的微服务在一个局域网内，或者说在一个 K8s 集群下，那么可以通过 Service 用于集群内 Pod 的访问，这就是 Service 默认的一种类型 ClusterIP，ClusterIP 这种的默认会自动分配地址。</p><p>那么问题来了，既然可以通过上面的 ClusterIp 来实现集群内部的服务访问，那么如何注册服务呢？其实 K8s 并没有引入任何的注册中心，使用的就是 K8s 的 kube-dns 组件。然后 K8s 将 Service 的名称当做域名注册到 kube-dns 中，通过 Service 的名称就可以访问其提供的服务。那么问题又来了，如果一个服务的 pod 对应有多个，那么如何实现 LB？其实，最终通过 kube-proxy，实现负载均衡。</p><p>说到这，我们来看下 Service 的服务发现与负载均衡的策略，Service 负载分发策略有两种：</p><ul><li>RoundRobin：轮询模式，即轮询将请求转发到后端的各个 pod 上，其为默认模式。</li><li>SessionAffinity：基于客户端 IP 地址进行会话保持的模式，类似 IP Hash 的方式，来实现服务的负载均衡。</li></ul><p>其实，K8s 利用其 Service 实现服务的发现，其实说白了，就是通过域名进行层层解析，最后解析到容器内部的 ip 和 port 来找到对应的服务，以完成请求。</p><p>下面写一个很简单的例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: cas-server-service</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: cas-server01</span><br><span class="line">    port: 2000</span><br><span class="line">    targetPort: cas-server01</span><br><span class="line">  selector:</span><br><span class="line">    app: cas-server</span><br></pre></td></tr></tbody></table></figure><p>可以看到执行 <code>kubectl apply -f service.yaml</code> 后：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~$ kubectl get svc</span><br><span class="line">NAME                          TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)              AGE</span><br><span class="line">admin-web-service             ClusterIP   10.16.129.24    &lt;none&gt;        2001/TCP              84d</span><br><span class="line">cas-server-service            ClusterIP   10.16.230.167   &lt;none&gt;        2000/TCP               67d</span><br><span class="line">cloud-admin-service-service   ClusterIP   10.16.25.178    &lt;none&gt;        1001/TCP         190d</span><br></pre></td></tr></tbody></table></figure><p>这样，我们可以看到默认的类型是 ClusterIP，用于为集群内 Pod 访问时，可以先通过域名来解析到多个服务地址信息，然后再通过 LB 策略来选择其中一个作为请求的对象。</p><h3 id="K8s-如何来处理微服务中常用的配置"><a href="#K8s-如何来处理微服务中常用的配置" class="headerlink" title="K8s 如何来处理微服务中常用的配置"></a>K8s 如何来处理微服务中常用的配置</h3><p>在上面，我们讲过了几种创建 ConfigMap 的方式，其中有一种在 Java 中常常用到：通过创建 yml 文件来实现配置管理。</p><p>比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">kind: ConfigMap</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: cas-server</span><br><span class="line">data:</span><br><span class="line">  application.yaml: |-</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the World</span><br><span class="line">    ---</span><br><span class="line">    spring:</span><br><span class="line">      profiles: dev</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Dev</span><br><span class="line">    spring:</span><br><span class="line">      profiles: test</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Test</span><br><span class="line">    spring:</span><br><span class="line">      profiles: prod</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Prod</span><br></pre></td></tr></tbody></table></figure><p>上面创建了一个 yml 文件，同时，通过 spring.profiles 指定了开发、测试、生产等每种环境的配置。</p><p>具体代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: cas-server-deployment</span><br><span class="line">  labels:</span><br><span class="line">    app: cas-server</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: cas-server</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: cas-server</span><br><span class="line">    spec:</span><br><span class="line">      nodeSelector:</span><br><span class="line">        cas-server: "true"</span><br><span class="line">      containers:</span><br><span class="line">      - name: cas-server</span><br><span class="line">        image: {{ cluster_cfg['cluster']['docker-registry']['prefix'] }}cas-server</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        ports:</span><br><span class="line">          - name: cas-server01</span><br><span class="line">            containerPort: 2000</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: /home/cas-server</span><br><span class="line">          name: cas-server-path</span><br><span class="line">        args: ["sh", "-c", "nohup java $JAVA_OPTS -jar -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m -Xms1024m -Xmx1024m -Xmn256m -Xss256k -XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC cas-server.jar --spring.profiles.active=dev", "&amp;"]</span><br><span class="line">      hostAliases:</span><br><span class="line">      - ip: "127.0.0.1"</span><br><span class="line">        hostnames:</span><br><span class="line">        - "gemantic.localhost"</span><br><span class="line">      - ip: "0.0.0.0"</span><br><span class="line">        hostnames:</span><br><span class="line">        - "gemantic.all"</span><br><span class="line">      volumes:</span><br><span class="line">      - name: cas-server-path</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /var/pai/cas-server</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这样，当我们启动容器时，通过 <code>--spring.profiles.active=dev</code> 来指定当前容器的活跃环境，即可获取 ConfigMap 中对应的配置。是不是感觉跟 Java 中的 Config 配置多个环境的配置有点类似呢？但是，我们不用那么复杂，这些统统可以交给 K8s 来处理。只需要你启动这一命令即可，是不是很简单？</p><h3 id="Spring-Boot-2-x-的新特性"><a href="#Spring-Boot-2-x-的新特性" class="headerlink" title="Spring Boot 2.x 的新特性"></a>Spring Boot 2.x 的新特性</h3><p>在第一节中，我们就讲到 1.x 与 2.x 的区别，其中最为凸显的是，Spring Boot 2.x 结合了 K8s 来实现微服务的架构设计。其实，在 K8s 中，更新 ConfigMap 后，pod 是不会自动刷新 configMap 中的变更，如果想要获取 ConfigMap 中最新的信息，需要重启 pod。</p><p>但 2.x 提供了自动刷新的功能：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cas-server</span><br><span class="line">  cloud:</span><br><span class="line">    kubernetes:</span><br><span class="line">      config:</span><br><span class="line">        sources:</span><br><span class="line">         - name: ${spring.application.name}</span><br><span class="line">           namespace: default</span><br><span class="line">      discovery:</span><br><span class="line">        all-namespaces: true</span><br><span class="line">      reload:</span><br><span class="line">        enabled: true</span><br><span class="line">        mode: polling</span><br><span class="line">        period: 500</span><br></pre></td></tr></tbody></table></figure><p>如上，我们打开了自动更新配置的开关，并且设置了自动更新的方式为主动拉取，时间间隔为 500ms，同时，还提供了另外一种方式——event 事件通知模式。这样，在 ConfigMap 发生改变时，无需重启 pod 即可获取最新的数据信息。</p><p>同时，Spring Boot 2.x 结合了 K8s 来实现微服务的服务注册与发现：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-cloud-kubernetes-core&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-cloud-kubernetes-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure><p>开启服务发现功能：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    kubernetes:</span><br><span class="line">      discovery:</span><br><span class="line">        all-namespaces: true</span><br></pre></td></tr></tbody></table></figure><p>开启后，我们在《<a href="https://xiao8.github.io/2020/07/23/micro-service03/">微服务 Spring Cloud 架构设计</a>》一文中讲过，其实最终是向 K8s 的 API Server 发起 http 请求，获取 Service 资源的数据列表。然后根据底层的负载均衡策略来实现服务的发现，最终解析到某个 pod 上。那么为了同一服务的多个 pod 存在，我们需要执行：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale --replicas=2 deployment admin-web-deployment</span><br></pre></td></tr></tbody></table></figure><p>同时，我们如果通过 HTTP 的 RestTemplate Client 来作服务请求时，可以配置一些请求的策略，RestTemplate 一般与 Ribbon 结合使用：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">client:</span><br><span class="line">  http:</span><br><span class="line">    request:</span><br><span class="line">      connectTimeout: 8000</span><br><span class="line">      readTimeout: 3000</span><br><span class="line"></span><br><span class="line">backend:</span><br><span class="line">  ribbon:</span><br><span class="line">    eureka:</span><br><span class="line">      enabled: false</span><br><span class="line">    client:</span><br><span class="line">      enabled: true</span><br><span class="line">    ServerListRefreshInterval: 5000</span><br><span class="line"></span><br><span class="line">ribbon:</span><br><span class="line">  ConnectTimeout: 8000</span><br><span class="line">  ReadTimeout: 3000</span><br><span class="line">  eager-load:</span><br><span class="line">    enabled: true</span><br><span class="line">    clients: cas-server-service,admin-web-service</span><br><span class="line">  MaxAutoRetries: 1 #对第一次请求的服务的重试次数</span><br><span class="line">  MaxAutoRetriesNextServer: 1 #要重试的下一个服务的最大数量（不包括第一个服务）</span><br><span class="line">  #ServerListRefreshInterval: 2000</span><br><span class="line">  OkToRetryOnAllOperations: true</span><br><span class="line">  NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule #com.damon.config.RibbonConfiguration #分布式负载均衡策略</span><br></pre></td></tr></tbody></table></figure><p>可以配置一些服务列表，自定义一些负载均衡的策略。</p><p>如果你是使用 Feign 来作为 LB，其实与 Ribbon 只有一点点不一样，因为 Feign 本身是基于 Ribbon 来实现的，除了加上注解 @EnableFeignClients 后，还要配置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">  client:</span><br><span class="line">    config:</span><br><span class="line">      default: #provider-service</span><br><span class="line">        connectTimeout: 8000 #客户端连接超时时间</span><br><span class="line">        readTimeout: 3000 #客户端读超时设置</span><br><span class="line">        loggerLevel: full</span><br></pre></td></tr></tbody></table></figure><p>其他的可以自定义负载均衡策略，这一点是基于 Ribbon 的，所以是一样的。</p><h3 id="实战-Spring-Boot-2-x-结合-K8s-来实现微服务架构设计"><a href="#实战-Spring-Boot-2-x-结合-K8s-来实现微服务架构设计" class="headerlink" title="实战 Spring Boot 2.x 结合 K8s 来实现微服务架构设计"></a>实战 Spring Boot 2.x 结合 K8s 来实现微服务架构设计</h3><p>微服务架构中，主要的就是服务消费者、服务的生产者可以互通，可以发生调用，在这基础上，还可以实现负载均衡，即一个服务调用另一个服务时，在该服务存在多个节点的情况下，可以通过一些策略来找到该服务的一个合适的节点访问。下面主要介绍服务的生产者与消费者。</p><p>先看生产者，引入常用的依赖：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.13.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">&lt;swagger.version&gt;2.6.1&lt;/swagger.version&gt;</span><br><span class="line">&lt;xstream.version&gt;1.4.7&lt;/xstream.version&gt;</span><br><span class="line">&lt;pageHelper.version&gt;4.1.6&lt;/pageHelper.version&gt;</span><br><span class="line">&lt;fastjson.version&gt;1.2.51&lt;/fastjson.version&gt;</span><br><span class="line">&lt;springcloud.version&gt;Greenwich.SR3&lt;/springcloud.version&gt;</span><br><span class="line">&lt;springcloud.kubernetes.version&gt;1.1.1.RELEASE&lt;/springcloud.kubernetes.version&gt;</span><br><span class="line">&lt;mysql.version&gt;5.1.46&lt;/mysql.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${springcloud.version}&lt;/version&gt;</span><br><span class="line">&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;exclusions&gt;</span><br><span class="line">&lt;exclusion&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">&lt;/exclusion&gt;</span><br><span class="line">&lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置加载依赖 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-actuator-autoconfigure&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-kubernetes-config&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jjwt&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.9.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.6.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;19.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${swagger.version}&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${swagger.version}&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 数据库分页依赖 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;${pageHelper.version}&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${mysql.version}&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 数据库驱动 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${fastjson.version}&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.jsoup&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jsoup&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.11.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></tbody></table></figure><p>上面我们使用了比较新的版本：Spring Boot 2.1.13，Cloud 版本是 Greenwich.SR3，其次，我们配置了 K8s 的 ConfigMap 所用的依赖，加上了数据库的一些配置，具体其他的，实现过程中，大家可以自行添加。</p><p>接下来，我们看启动时加载的配置文件，这里加了关于 K8s ConfigMap 所管理的配置所在的信息，以及保证服务被发现，开启了所有的 namespace，同时还启动了配置自动刷新的功能，注意的是，该配置需要在 bootstrap 文件：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cas-server</span><br><span class="line">  cloud:</span><br><span class="line">    kubernetes:</span><br><span class="line">      config:</span><br><span class="line">        sources:</span><br><span class="line">         - name: ${spring.application.name}</span><br><span class="line">           namespace: default</span><br><span class="line">      discovery:</span><br><span class="line">        all-namespaces: true #发现所有的命令空间的服务</span><br><span class="line">      reload:</span><br><span class="line">        enabled: true</span><br><span class="line">        mode: polling #自动刷新模式为拉取模式，也可以是事件模式 event</span><br><span class="line">        period: 500 #拉取模式下的频率</span><br><span class="line"></span><br><span class="line">logging: #日志路径设置</span><br><span class="line">  path: /data/${spring.application.name}/logs</span><br></pre></td></tr></tbody></table></figure><p>剩下的一些配置可以在 application 文件中配置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 2000</span><br><span class="line">  undertow:</span><br><span class="line">    accesslog:</span><br><span class="line">      enabled: false</span><br><span class="line">      pattern: combined</span><br><span class="line">  servlet:</span><br><span class="line">    session:</span><br><span class="line">      timeout: PT120M #session 超时时间</span><br><span class="line"></span><br><span class="line">client:</span><br><span class="line">  http:</span><br><span class="line">    request:</span><br><span class="line">      connectTimeout: 8000</span><br><span class="line">      readTimeout: 30000</span><br><span class="line"></span><br><span class="line">mybatis: #持久层配置</span><br><span class="line">  mapperLocations: classpath:mapper/*.xml</span><br><span class="line">  typeAliasesPackage: com.damon.*.model</span><br></pre></td></tr></tbody></table></figure><p>接下来看下启动类：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * @author Damon</span><br><span class="line"> * @date 2020 年 1 月 13 日 下午 8:29:42</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(basePackages = {"com.damon"})</span><br><span class="line">//@SpringBootApplication(scanBasePackages = { "com.damon" })</span><br><span class="line">@EnableConfigurationProperties(EnvConfig.class)</span><br><span class="line">public class CasApp {</span><br><span class="line">public static void main(String[] args) {</span><br><span class="line">SpringApplication.run(CasApp.class, args);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里我们没有直接用注解 @SpringBootApplication，因为主要用到的就是几个配置，没必要全部加载。</p><p>我们看到启动类中有一个引入的 EnvConfig.class：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author Damon</span><br><span class="line"> * @date 2019 年 10 月 25 日 下午 8:54:01</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ConfigurationProperties(prefix = "greeting")</span><br><span class="line">public class EnvConfig {</span><br><span class="line"></span><br><span class="line">    private String message = "This is a dummy message";</span><br><span class="line"></span><br><span class="line">    public String getMessage() {</span><br><span class="line">        return this.message;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setMessage(String message) {</span><br><span class="line">        this.message = message;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>这就是配置 ConfigMap 中的属性的类。剩下的可以自己定义一个接口类，来实现服务生产者。</p><p>最后，我们需要在 K8s 下部署的话，需要准备几个脚本。</p><p><strong>1. 创建 ConfigMap</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">kind: ConfigMap</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: cas-server</span><br><span class="line">data:</span><br><span class="line">  application.yaml: |-</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the World</span><br><span class="line">    ---</span><br><span class="line">    spring:</span><br><span class="line">      profiles: dev</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Dev</span><br><span class="line">    spring:</span><br><span class="line">      profiles: test</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Test</span><br><span class="line">    spring:</span><br><span class="line">      profiles: prod</span><br><span class="line">    greeting:</span><br><span class="line">      message: Say Hello to the Prod</span><br></pre></td></tr></tbody></table></figure><p>设置了不同环境的配置，注意，这里的 namespace 需要与服务部署的 namespace 一致，这里默认的是 default，而且在创建服务之前，先得创建这个。</p><p><strong>2. 创建服务部署脚本</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: cas-server-deployment</span><br><span class="line">  labels:</span><br><span class="line">    app: cas-server</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: cas-server</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: cas-server</span><br><span class="line">    spec:</span><br><span class="line">      nodeSelector:</span><br><span class="line">        cas-server: "true"</span><br><span class="line">      containers:</span><br><span class="line">      - name: cas-server</span><br><span class="line">        image: cas-server</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        ports:</span><br><span class="line">          - name: cas-server01</span><br><span class="line">            containerPort: 2000</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: /home/cas-server</span><br><span class="line">          name: cas-server-path</span><br><span class="line">        - mountPath: /data/cas-server</span><br><span class="line">          name: cas-server-log-path</span><br><span class="line">        - mountPath: /etc/kubernetes</span><br><span class="line">          name: kube-config-path</span><br><span class="line">        args: ["sh", "-c", "nohup java $JAVA_OPTS -jar -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m -Xms1024m -Xmx1024m -Xmn256m -Xss256k -XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC cas-server.jar --spring.profiles.active=dev", "&amp;"]</span><br><span class="line">      volumes:</span><br><span class="line">      - name: cas-server-path</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /var/pai/cas-server</span><br><span class="line">      - name: cas-server-log-path</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /data/cas-server</span><br><span class="line">      - name: kube-config-path</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /etc/kubernetes</span><br></pre></td></tr></tbody></table></figure><p>注意：这里有个属性 replicas，其作用是当前 pod 所启动的副本数，即我们常说的启动的节点个数，当然，你也可以通过前面讲的脚本来执行生成多个 pod 副本。如果这里没有设置多个的话，也可以通过命令来执行：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale --replicas=3 deployment cas-server-deployment</span><br></pre></td></tr></tbody></table></figure><p>这里，我建议使用 Deployment 类型的来创建 pod，因为 Deployment 类型更好的支持弹性伸缩与滚动更新。</p><p>同时，我们通过 <code>--spring.profiles.active=dev</code> 来指定当前 pod 的运行环境。</p><p><strong>3. 创建一个 Service</strong></p><p>最后，如果服务想被发现，需要创建一个 Service：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: cas-server-service</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: cas-server01</span><br><span class="line">    port: 2000</span><br><span class="line">    targetPort: cas-server01</span><br><span class="line">  selector:</span><br><span class="line">    app: cas-server</span><br></pre></td></tr></tbody></table></figure><p>注意，这里的 namespace 需要与服务部署的 namespace 一致，这里默认的是 default。</p><p>看看服务的消费者，同样，先看引入常用的依赖：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.13.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">&lt;swagger.version&gt;2.6.1&lt;/swagger.version&gt;</span><br><span class="line">&lt;xstream.version&gt;1.4.7&lt;/xstream.version&gt;</span><br><span class="line">&lt;pageHelper.version&gt;4.1.6&lt;/pageHelper.version&gt;</span><br><span class="line">&lt;fastjson.version&gt;1.2.51&lt;/fastjson.version&gt;</span><br><span class="line">&lt;springcloud.version&gt;Greenwich.SR3&lt;/springcloud.version&gt;</span><br><span class="line">&lt;!-- &lt;springcloud.version&gt;2.1.8.RELEASE&lt;/springcloud.version&gt; --&gt;</span><br><span class="line">&lt;springcloud.kubernetes.version&gt;1.1.1.RELEASE&lt;/springcloud.kubernetes.version&gt;</span><br><span class="line">&lt;mysql.version&gt;5.1.46&lt;/mysql.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${springcloud.version}&lt;/version&gt;</span><br><span class="line">&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;exclusions&gt;</span><br><span class="line">&lt;exclusion&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">&lt;/exclusion&gt;</span><br><span class="line">&lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 配置加载依赖 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-actuator&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-actuator-autoconfigure&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-kubernetes-config&lt;/artifactId&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-commons&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 结合 k8s 实现服务发现 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-kubernetes-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-kubernetes-discovery&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 负载均衡策略 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-kubernetes-ribbon&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 熔断机制 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.6.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${fastjson.version}&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.jsoup&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jsoup&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.11.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${swagger.version}&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${swagger.version}&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 数据库分页 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;${pageHelper.version}&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;${mysql.version}&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 数据库驱动 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></tbody></table></figure><p>这里大部分的依赖跟生产者一样，但，需要加入服务发现的依赖，以及所用的负载均衡的策略依赖、服务的熔断机制。</p><p>接下来 bootstrap 文件中的配置跟生产者一样，这里不在说了，唯一不同的是 application 文件：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">backend:</span><br><span class="line">  ribbon:</span><br><span class="line">    eureka:</span><br><span class="line">      enabled: false</span><br><span class="line">    client:</span><br><span class="line">      enabled: true</span><br><span class="line">    ServerListRefreshInterval: 5000</span><br><span class="line"></span><br><span class="line">ribbon:</span><br><span class="line">  ConnectTimeout: 3000</span><br><span class="line">  ReadTimeout: 1000</span><br><span class="line">  eager-load:</span><br><span class="line">    enabled: true</span><br><span class="line">    clients: cas-server-service,edge-cas-service,admin-web-service #负载均衡发现的服务列表</span><br><span class="line">  MaxAutoRetries: 1 #对第一次请求的服务的重试次数</span><br><span class="line">  MaxAutoRetriesNextServer: 1 #要重试的下一个服务的最大数量（不包括第一个服务）</span><br><span class="line">  OkToRetryOnAllOperations: true</span><br><span class="line">  NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule #负载均衡策略</span><br><span class="line"></span><br><span class="line">hystrix:</span><br><span class="line">  command:</span><br><span class="line">    BackendCall:</span><br><span class="line">      execution:</span><br><span class="line">        isolation:</span><br><span class="line">          thread:</span><br><span class="line">            timeoutInMilliseconds: 5000 #熔断机制设置的超时时间</span><br><span class="line">  threadpool:</span><br><span class="line">    BackendCallThread:</span><br><span class="line">      coreSize: 5</span><br></pre></td></tr></tbody></table></figure><p>引入了负载均衡的机制以及策略（可以自定义策略）。</p><p>接下来看启动类：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author Damon</span><br><span class="line"> * @date 2020 年 1 月 13 日 下午 9:23:06</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(basePackages = {"com.damon"})</span><br><span class="line">@EnableConfigurationProperties(EnvConfig.class)</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class AdminApp {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        SpringApplication.run(AdminApp.class, args);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同样的 EnvConfig 类，这里不再展示了。其他的比如：注解 @EnableDiscoveryClient 是为了服务发现。</p><p>同样，我们新建接口，假如我们生产者有一个接口是：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://cas-server-service/api/getUser</span><br></pre></td></tr></tbody></table></figure><p>则，我们在调用它时，可以通过 RestTemplate Client 来直接调用，通过 Ribbon 来实现负载均衡：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@LoadBalanced</span><br><span class="line">@Bean</span><br><span class="line">public RestTemplate restTemplate() {</span><br><span class="line">SimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();</span><br><span class="line">requestFactory.setReadTimeout(env.getProperty("client.http.request.readTimeout", Integer.class, 15000));</span><br><span class="line">requestFactory.setConnectTimeout(env.getProperty("client.http.request.connectTimeout", Integer.class, 3000));</span><br><span class="line">RestTemplate rt = new RestTemplate(requestFactory);</span><br><span class="line">return rt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，这种方式的分布式负载均衡实现起来很简单，直接注入一个初始化 Bean，加上一个注解 @LoadBalanced 即可。</p><p>在实现类中，我们只要直接调用服务生产者：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;String&gt; forEntity = restTemplate.getForEntity("http://cas-server/api/getUser", String.class);</span><br></pre></td></tr></tbody></table></figure><p>其中，URL 中 必须要加上 <code>"http://"</code>，这样即可实现服务的发现以及负载均衡，其中，LB 的策略，可以采用 Ribbon 的几种方式，也可以自定义一种。</p><p>最后，可以在实现类上加一个熔断机制：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@HystrixCommand(fallbackMethod = "admin_service_fallBack")</span><br><span class="line">public Response&lt;Object&gt; getUserInfo(HttpServletRequest req, HttpServletResponse res) {</span><br><span class="line"></span><br><span class="line">ResponseEntity&lt;String&gt; forEntity = restTemplate.getForEntity(envConfig.getCas_server_url() + "/api/getUser", String.class);</span><br><span class="line">        logger.info("test restTemplate.getForEntity(): {}", forEntity);</span><br><span class="line">        if (forEntity.getStatusCodeValue() == 200) {</span><br><span class="line">                logger.info("================================test restTemplate.getForEntity(): {}", JSON.toJSON(forEntity.getBody()));</span><br><span class="line">                logger.info(JSON.toJSONString(forEntity.getBody()));</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中发生熔断时，回调方法：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private Response&lt;Object&gt; admin_service_fallBack(HttpServletRequest req, HttpServletResponse res) {</span><br><span class="line">String token = StrUtil.subAfter(req.getHeader("Authorization"), "bearer ", false);</span><br><span class="line">logger.info("admin_service_fallBack token: {}", token);</span><br><span class="line">return Response.ok(200, -5, "服务挂啦!", null);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其返回的对象必须与原函数一致，否则可能会报错。具体的可以参考《<a href="https://mp.weixin.qq.com/s/TcwAONaCexKIeT-63ClGsg">Spring cloud 之熔断机制</a>》。</p><p>最后与生产者一样，需要创建 ConfigMap、Service、服务部署脚本，下面会开源这些代码，这里也就不一一展示了。最后，我们会发现：当请求 认证中心时，认证中心存在的多个 pod，可以被轮训的请求到。这就是基于 Ribbon 的轮训策略来实现分布式的负载均衡，并且基于 Redis 来实现信息共享。</p><h3 id="结束福利"><a href="#结束福利" class="headerlink" title="结束福利"></a>结束福利</h3><p>开源几个微服务的架构设计项目：</p><ul><li><a href="https://github.com/damon008/spring-cloud-oauth2">https://github.com/damon008/spring-cloud-oauth2</a></li><li><a href="https://github.com/damon008/spring-cloud-k8s">https://github.com/damon008/spring-cloud-k8s</a></li><li><a href="https://gitee.com/damon_one/spring-cloud-k8s">https://gitee.com/damon_one/spring-cloud-k8s</a></li><li><a href="https://gitee.com/damon_one/spring-cloud-oauth2">https://gitee.com/damon_one/spring-cloud-oauth2</a></li></ul><p>欢迎大家 star，多多指教。</p><h3 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h3><p>笔名：Damon，技术爱好者，长期从事 Java 开发、Spring Cloud 的微服务架构设计，以及结合 Docker、K8s 做微服务容器化，自动化部署等一站式项目部署、落地。目前主要从事基于 K8s 云原生架构研发的工作。Golang 语言开发，长期研究边缘计算框架 KubeEdge、调度框架 Volcano 等。公众号<strong>程序猿 Damon</strong> 发起人。个人微信 <strong>MrNull008</strong>，欢迎來撩。</p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://www.infoq.cn/profile/1905020/following/user" title="InfoQ">InfoQ</a></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">欢迎关注：<a class="nav-item-link" target="_blank" href="https://cloud.tencent.com/developer/column/invite/533b1afb" title="">腾讯自媒体专栏</a></p><br><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">欢迎关注</span><span class="suffix"></span></h2><p><img src="https://static001.geekbang.org/infoq/38/385163791aa296c4cc23be10afa5631d.jpeg" alt="公号：交个朋友之猿天地"></p><p><img src="https://static001.geekbang.org/infoq/86/860561234baac42a49dac2ea24239882.jpeg" alt="公号：damon8"></p><p><img src="https://static001.geekbang.org/infoq/31/31b11ee840215b57487aa0269453e572.jpeg" alt="公号：天山六路折梅手"></p><br>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="后端" scheme="http://xiao8.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://xiao8.github.io/tags/Java/"/>
    
    <category term="后端" scheme="http://xiao8.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="K8s" scheme="http://xiao8.github.io/tags/K8s/"/>
    
  </entry>
  
</feed>
